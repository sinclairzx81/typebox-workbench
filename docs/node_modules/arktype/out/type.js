import { ArkErrors, BaseRoot, GenericRoot } from "@ark/schema";
import { Callable } from "@ark/util";
import { parseGenericParams } from "./generic.js";
export class InternalTypeParser extends Callable {
    constructor($) {
        super((...args) => {
            if (args.length === 1) {
                // treat as a simple definition
                return $.parseRoot(args[0]);
            }
            if (args.length === 2 &&
                typeof args[0] === "string" &&
                args[0][0] === "<" &&
                args[0].at(-1) === ">") {
                // if there are exactly two args, the first of which looks like <${string}>,
                // treat as a generic
                const params = parseGenericParams(args[0].slice(1, -1), {
                    $,
                    args: {}
                });
                return new GenericRoot(params, args[1], $, $);
            }
            // otherwise, treat as a tuple expression. technically, this also allows
            // non-expression tuple definitions to be parsed, but it's not a supported
            // part of the API as specified by the associated types
            return $.parseRoot(args);
        }, {
            bind: $,
            attach: {
                errors: ArkErrors,
                raw: $.parseRoot
            }
        });
    }
}
export const Type = BaseRoot;
