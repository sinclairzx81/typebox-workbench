function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
    return _classApplyDescriptorGet(receiver, descriptor);
}
function _classPrivateFieldInit(obj, privateMap, value) {
    _checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
    _classApplyDescriptorSet(receiver, descriptor, value);
    return value;
}
function _classPrivateMethodGet(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return fn;
}
function _classPrivateMethodInit(obj, privateSet) {
    _checkPrivateRedeclaration(obj, privateSet);
    privateSet.add(obj);
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
import { flattenType, isConfigNode } from "../nodes/node.js";
import { parseDefinition } from "../parse/definition.js";
import { compileProblemWriters } from "../traverse/problems.js";
import { chainableNoOpProxy } from "../utils/chainableNoOpProxy.js";
import { throwInternalError, throwParseError } from "../utils/errors.js";
import { deepFreeze } from "../utils/freeze.js";
import { hasKeys } from "../utils/generics.js";
import { Path } from "../utils/paths.js";
import { Cache, FreezingCache } from "./cache.js";
import { initializeType } from "./type.js";
export const compileScopeOptions = (opts)=>({
        codes: compileProblemWriters(opts.codes),
        keys: opts.keys ?? "loose"
    });
let anonymousScopeCount = 0;
const scopeRegistry = {};
const spaceRegistry = {};
export const isConfigTuple = (def)=>Array.isArray(def) && def[1] === ":";
var _resolutions = /*#__PURE__*/ new WeakMap(), _exports = /*#__PURE__*/ new WeakMap(), _register = /*#__PURE__*/ new WeakSet(), _cacheSpaces = /*#__PURE__*/ new WeakSet(), _initializeContext = /*#__PURE__*/ new WeakSet(), _resolveRecurse = /*#__PURE__*/ new WeakSet();
export class Scope {
    getAnonymousQualifiedName(base) {
        let increment = 0;
        let id = base;
        while(this.isResolvable(id)){
            id = `${base}${increment++}`;
        }
        return `${this.name}.${id}`;
    }
    addAnonymousTypeReference(referencedType, ctx) {
        var _ctx_type;
        (_ctx_type = ctx.type).includesMorph || (_ctx_type.includesMorph = referencedType.includesMorph);
        return referencedType.node;
    }
    get infer() {
        return chainableNoOpProxy;
    }
    compile() {
        if (!spaceRegistry[this.name]) {
            for(const name in this.aliases){
                this.resolve(name);
            }
            spaceRegistry[this.name] = _classPrivateFieldGet(this, _exports).root;
        }
        return _classPrivateFieldGet(this, _exports).root;
    }
    addParsedReferenceIfResolvable(name, ctx) {
        var _ctx_type;
        const resolution = _classPrivateMethodGet(this, _resolveRecurse, resolveRecurse).call(this, name, "undefined", [
            name
        ]);
        if (!resolution) {
            return false;
        }
        (_ctx_type = ctx.type).includesMorph || (_ctx_type.includesMorph = resolution.includesMorph);
        return true;
    }
    resolve(name) {
        return _classPrivateMethodGet(this, _resolveRecurse, resolveRecurse).call(this, name, "throw", [
            name
        ]);
    }
    resolveNode(node) {
        return typeof node === "string" ? this.resolveNode(this.resolve(node).node) : node;
    }
    resolveTypeNode(node) {
        const resolution = this.resolveNode(node);
        return isConfigNode(resolution) ? resolution.node : resolution;
    }
    isResolvable(name) {
        return _classPrivateFieldGet(this, _resolutions).has(name) || this.aliases[name];
    }
    constructor(aliases, opts = {}){
        _classPrivateMethodInit(this, _register);
        _classPrivateMethodInit(this, _cacheSpaces);
        _classPrivateMethodInit(this, _initializeContext);
        _classPrivateMethodInit(this, _resolveRecurse);
        _defineProperty(this, "aliases", void 0);
        _defineProperty(this, "name", void 0);
        _defineProperty(this, "config", void 0);
        _defineProperty(this, "parseCache", void 0);
        _classPrivateFieldInit(this, _resolutions, {
            writable: true,
            value: void 0
        });
        _classPrivateFieldInit(this, _exports, {
            writable: true,
            value: void 0
        });
        _defineProperty(this, "expressions", void 0);
        _defineProperty(this, "intersection", void 0);
        _defineProperty(this, "union", void 0);
        _defineProperty(this, "arrayOf", void 0);
        _defineProperty(this, "keyOf", void 0);
        _defineProperty(this, "valueOf", void 0);
        _defineProperty(this, "instanceOf", void 0);
        _defineProperty(this, "narrow", void 0);
        _defineProperty(this, "morph", void 0);
        _defineProperty(this, "type", void 0);
        this.aliases = aliases;
        this.parseCache = new FreezingCache();
        _classPrivateFieldSet(this, _resolutions, new Cache());
        _classPrivateFieldSet(this, _exports, new Cache());
        this.expressions = {
            intersection: (l, r, opts)=>this.type([
                    l,
                    "&",
                    r
                ], opts),
            union: (l, r, opts)=>this.type([
                    l,
                    "|",
                    r
                ], opts),
            arrayOf: (def, opts)=>this.type([
                    def,
                    "[]"
                ], opts),
            keyOf: (def, opts)=>this.type([
                    "keyof",
                    def
                ], opts),
            node: (def, opts)=>this.type([
                    "node",
                    def
                ], opts),
            instanceOf: (def, opts)=>this.type([
                    "instanceof",
                    def
                ], opts),
            valueOf: (def, opts)=>this.type([
                    "===",
                    def
                ], opts),
            narrow: (def, fn, opts)=>this.type([
                    def,
                    "=>",
                    fn
                ], opts),
            morph: (def, fn, opts)=>this.type([
                    def,
                    "|>",
                    fn
                ], opts)
        };
        this.intersection = this.expressions.intersection;
        this.union = this.expressions.union;
        this.arrayOf = this.expressions.arrayOf;
        this.keyOf = this.expressions.keyOf;
        this.valueOf = this.expressions.valueOf;
        this.instanceOf = this.expressions.instanceOf;
        this.narrow = this.expressions.narrow;
        this.morph = this.expressions.morph;
        this.type = Object.assign((def, config = {})=>{
            const t = initializeType("Î»type", def, config, this);
            const ctx = _classPrivateMethodGet(this, _initializeContext, initializeContext).call(this, t);
            const root = parseDefinition(def, ctx);
            t.node = deepFreeze(hasKeys(config) ? {
                config,
                node: this.resolveTypeNode(root)
            } : root);
            t.flat = deepFreeze(flattenType(t));
            return t;
        }, {
            from: this.expressions.node
        });
        this.name = _classPrivateMethodGet(this, _register, register).call(this, opts);
        if (opts.standard !== false) {
            _classPrivateMethodGet(this, _cacheSpaces, cacheSpaces).call(this, [
                spaceRegistry["standard"]
            ], "imports");
        }
        if (opts.imports) {
            _classPrivateMethodGet(this, _cacheSpaces, cacheSpaces).call(this, opts.imports, "imports");
        }
        if (opts.includes) {
            _classPrivateMethodGet(this, _cacheSpaces, cacheSpaces).call(this, opts.includes, "includes");
        }
        this.config = compileScopeOptions(opts);
    }
}
function register(opts) {
    const name = opts.name ? scopeRegistry[opts.name] ? throwParseError(`A scope named '${opts.name}' already exists`) : opts.name : `scope${++anonymousScopeCount}`;
    scopeRegistry[name] = this;
    return name;
}
function cacheSpaces(spaces, kind) {
    for (const space of spaces){
        for(const name in space){
            if (_classPrivateFieldGet(this, _resolutions).has(name) || name in this.aliases) {
                throwParseError(writeDuplicateAliasesMessage(name));
            }
            _classPrivateFieldGet(this, _resolutions).set(name, space[name]);
            if (kind === "includes") {
                _classPrivateFieldGet(this, _exports).set(name, space[name]);
            }
        }
    }
}
function initializeContext(type) {
    return {
        type,
        path: new Path()
    };
}
function resolveRecurse(name, onUnresolvable, seen) {
    const maybeCacheResult = _classPrivateFieldGet(this, _resolutions).get(name);
    if (maybeCacheResult) {
        return maybeCacheResult;
    }
    const aliasDef = this.aliases[name];
    if (!aliasDef) {
        return onUnresolvable === "throw" ? throwInternalError(`Unexpectedly failed to resolve alias '${name}'`) : undefined;
    }
    const t = initializeType(name, aliasDef, {}, this);
    const ctx = _classPrivateMethodGet(this, _initializeContext, initializeContext).call(this, t);
    _classPrivateFieldGet(this, _resolutions).set(name, t);
    _classPrivateFieldGet(this, _exports).set(name, t);
    let node = parseDefinition(aliasDef, ctx);
    if (typeof node === "string") {
        if (seen.includes(node)) {
            return throwParseError(writeShallowCycleErrorMessage(name, seen));
        }
        seen.push(node);
        node = _classPrivateMethodGet(this, _resolveRecurse, resolveRecurse).call(this, node, "throw", seen).node;
    }
    t.node = deepFreeze(node);
    t.flat = deepFreeze(flattenType(t));
    return t;
}
export const scope = (aliases, opts = {})=>new Scope(aliases, opts);
export const rootScope = scope({}, {
    name: "root",
    standard: false
});
export const rootType = rootScope.type;
export const writeShallowCycleErrorMessage = (name, seen)=>`Alias '${name}' has a shallow resolution cycle: ${[
        ...seen,
        name
    ].join("=>")}`;
export const writeDuplicateAliasesMessage = (name)=>`Alias '${name}' is already defined`;
