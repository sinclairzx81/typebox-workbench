import type { Node, ResolvedNode, TypeNode } from "../nodes/node.js";
import type { ConfigTuple } from "../parse/ast/config.js";
import type { inferDefinition, ParseContext, validateDefinition } from "../parse/definition.js";
import type { ProblemsConfig, ProblemWritersByCode } from "../traverse/problems.js";
import type { Dict, error, evaluate, isAny, List, nominal } from "../utils/generics.js";
import type { stringifyUnion } from "../utils/unionToTuple.js";
import type { PrecompiledDefaults } from "./ark.js";
import { FreezingCache } from "./cache.js";
import type { Expressions } from "./expressions.js";
import type { AnonymousTypeName, KeyCheckKind, QualifiedTypeName, Type, TypeParser } from "./type.js";
type ScopeParser = {
    <aliases>(aliases: validateAliases<aliases, {}>): Scope<parseScope<aliases, {}>>;
    <aliases, opts extends ScopeOptions>(aliases: validateAliases<aliases, opts>, opts: validateOptions<opts>): Scope<parseScope<aliases, opts>>;
};
type validateAliases<aliases, opts extends ScopeOptions> = evaluate<{
    [name in keyof aliases]: name extends keyof preresolved<opts> ? writeDuplicateAliasesMessage<name & string> : validateDefinition<aliases[name], bootstrapScope<aliases, opts>>;
}>;
export type ScopeOptions = {
    imports?: Space[] | [];
    includes?: Space[] | [];
    standard?: boolean;
    name?: string;
    codes?: ProblemsConfig;
    keys?: KeyCheckKind;
};
export type ScopeConfig = evaluate<{
    keys: KeyCheckKind;
    codes: ProblemWritersByCode;
}>;
export declare const compileScopeOptions: (opts: ScopeOptions) => ScopeConfig;
type validateOptions<opts extends ScopeOptions> = {
    [k in keyof opts]: k extends "imports" | "includes" ? mergeSpaces<opts[k], [
        k,
        "imports"
    ] extends ["includes", keyof opts] ? mergeSpaces<opts["includes"]> : {}> extends error<infer e> ? e : opts[k] : opts[k];
};
export type ScopeContext = Dict | ScopeContextTuple;
type ScopeContextTuple = [exports: Dict, locals: Dict, standard?: false];
type parseScope<aliases, opts extends ScopeOptions> = opts["standard"] extends false ? [inferExports<aliases, opts>, importsOf<opts>, false] : opts["imports"] extends Space[] ? [inferExports<aliases, opts>, importsOf<opts>] : inferExports<aliases, opts>;
type importsOf<opts extends ScopeOptions> = unknown extends opts["imports"] ? {} : mergeSpaces<opts["imports"]>;
type includesOf<opts extends ScopeOptions> = unknown extends opts["includes"] ? {} : mergeSpaces<opts["includes"]>;
export type resolve<name extends keyof $, $> = isAny<$[name]> extends true ? any : $[name] extends alias<infer def> ? inferDefinition<def, $> : $[name];
type exportsOf<context extends ScopeContext> = context extends [
    infer exports,
    ...unknown[]
] ? exports : context;
type localsOf<context extends ScopeContext> = context extends List ? context["1"] & (context["2"] extends false ? {} : PrecompiledDefaults) : PrecompiledDefaults;
type mergeSpaces<scopes, base extends Dict = {}> = scopes extends readonly [
    Space<infer head>,
    ...infer tail
] ? keyof base & keyof head extends never ? mergeSpaces<tail, base & head> : error<writeDuplicateAliasesMessage<stringifyUnion<keyof base & keyof head & string>>> : base;
type preresolved<opts extends ScopeOptions> = includesOf<opts> & importsOf<opts> & (opts["standard"] extends false ? {} : PrecompiledDefaults);
type alias<def = {}> = nominal<def, "alias">;
type bootstrapScope<aliases, opts extends ScopeOptions> = {
    [k in keyof aliases]: alias<aliases[k]>;
} & preresolved<opts>;
type inferExports<aliases, opts extends ScopeOptions> = evaluate<{
    [k in keyof aliases]: inferDefinition<aliases[k], bootstrapScope<aliases, opts>>;
} & includesOf<opts>>;
export type Space<exports = Dict> = {
    [k in keyof exports]: Type<exports[k]>;
};
type resolutions<context extends ScopeContext> = localsOf<context> & exportsOf<context>;
type name<context extends ScopeContext> = keyof resolutions<context> & string;
export declare const isConfigTuple: (def: unknown) => def is ConfigTuple;
export declare class Scope<context extends ScopeContext = any> {
    #private;
    aliases: Dict;
    name: string;
    config: ScopeConfig;
    parseCache: FreezingCache<Node>;
    constructor(aliases: Dict, opts?: ScopeOptions);
    getAnonymousQualifiedName(base: AnonymousTypeName): QualifiedTypeName;
    addAnonymousTypeReference(referencedType: Type, ctx: ParseContext): Node;
    get infer(): exportsOf<context>;
    compile(): Space<exportsOf<context>>;
    addParsedReferenceIfResolvable(name: name<context>, ctx: ParseContext): boolean;
    resolve(name: name<context>): Type;
    resolveNode(node: Node): ResolvedNode;
    resolveTypeNode(node: Node): TypeNode;
    expressions: Expressions<resolutions<context>>;
    intersection: import("./expressions.js").BinaryExpressionParser<resolutions<context>, "&">;
    union: import("./expressions.js").BinaryExpressionParser<resolutions<context>, "|">;
    arrayOf: import("./expressions.js").UnaryExpressionParser<resolutions<context>, "[]">;
    keyOf: import("./expressions.js").UnaryExpressionParser<resolutions<context>, "keyof">;
    valueOf: import("./expressions.js").UnvalidatedExpressionParser<resolutions<context>, "===">;
    instanceOf: import("./expressions.js").UnvalidatedExpressionParser<resolutions<context>, "instanceof">;
    narrow: import("./expressions.js").FunctionalExpressionParser<resolutions<context>, "=>">;
    morph: import("./expressions.js").FunctionalExpressionParser<resolutions<context>, "|>">;
    type: TypeParser<resolutions<context>>;
    isResolvable(name: string): unknown;
}
export declare const scope: ScopeParser;
export declare const rootScope: Scope<[{}, {}, false]>;
export declare const rootType: TypeParser<{}>;
export declare const writeShallowCycleErrorMessage: (name: string, seen: string[]) => string;
export declare const writeDuplicateAliasesMessage: <name_1 extends string>(name: name_1) => `Alias '${name_1}' is already defined`;
type writeDuplicateAliasesMessage<name extends string> = `Alias '${name}' is already defined`;
export {};
