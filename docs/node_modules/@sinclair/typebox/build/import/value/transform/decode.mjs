import { Kind, TransformKind } from '../../type/symbols/index.mjs';
import { TypeBoxError } from '../../type/error/index.mjs';
import { KeyOfPropertyKeys } from '../../type/keyof/index.mjs';
import { Index } from '../../type/indexed/index.mjs';
import { Deref } from '../deref/index.mjs';
import { Check } from '../check/index.mjs';
// ------------------------------------------------------------------
// ValueGuard
// ------------------------------------------------------------------
import { IsPlainObject, IsArray, IsValueType } from '../guard/index.mjs';
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
import { IsTransform, IsSchema } from '../../type/guard/type.mjs';
// ------------------------------------------------------------------
// Errors
// ------------------------------------------------------------------
// thrown externally
export class TransformDecodeCheckError extends TypeBoxError {
    schema;
    value;
    error;
    constructor(schema, value, error) {
        super(`Unable to decode due to invalid value`);
        this.schema = schema;
        this.value = value;
        this.error = error;
    }
}
export class TransformDecodeError extends TypeBoxError {
    schema;
    value;
    constructor(schema, value, error) {
        super(`${error instanceof Error ? error.message : 'Unknown error'}`);
        this.schema = schema;
        this.value = value;
    }
}
// ------------------------------------------------------------------
// Decode
// ------------------------------------------------------------------
// prettier-ignore
function Default(schema, value) {
    try {
        return IsTransform(schema) ? schema[TransformKind].Decode(value) : value;
    }
    catch (error) {
        throw new TransformDecodeError(schema, value, error);
    }
}
// prettier-ignore
function FromArray(schema, references, value) {
    return (IsArray(value))
        ? Default(schema, value.map((value) => Visit(schema.items, references, value)))
        : Default(schema, value);
}
// prettier-ignore
function FromIntersect(schema, references, value) {
    if (!IsPlainObject(value) || IsValueType(value))
        return Default(schema, value);
    const knownKeys = KeyOfPropertyKeys(schema);
    const knownProperties = knownKeys.reduce((value, key) => {
        return (key in value)
            ? { ...value, [key]: Visit(Index(schema, [key]), references, value[key]) }
            : value;
    }, value);
    if (!IsTransform(schema.unevaluatedProperties)) {
        return Default(schema, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const unevaluatedProperties = schema.unevaluatedProperties;
    const unknownProperties = unknownKeys.reduce((value, key) => {
        return !knownKeys.includes(key)
            ? { ...value, [key]: Default(unevaluatedProperties, value[key]) }
            : value;
    }, knownProperties);
    return Default(schema, unknownProperties);
}
function FromNot(schema, references, value) {
    return Default(schema, Visit(schema.not, references, value));
}
// prettier-ignore
function FromObject(schema, references, value) {
    if (!IsPlainObject(value))
        return Default(schema, value);
    const knownKeys = KeyOfPropertyKeys(schema);
    const knownProperties = knownKeys.reduce((value, key) => {
        return (key in value)
            ? { ...value, [key]: Visit(schema.properties[key], references, value[key]) }
            : value;
    }, value);
    if (!IsSchema(schema.additionalProperties)) {
        return Default(schema, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    const unknownProperties = unknownKeys.reduce((value, key) => {
        return !knownKeys.includes(key)
            ? { ...value, [key]: Default(additionalProperties, value[key]) }
            : value;
    }, knownProperties);
    return Default(schema, unknownProperties);
}
// prettier-ignore
function FromRecord(schema, references, value) {
    if (!IsPlainObject(value))
        return Default(schema, value);
    const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const knownKeys = new RegExp(pattern);
    const knownProperties = Object.getOwnPropertyNames(value).reduce((value, key) => {
        return knownKeys.test(key)
            ? { ...value, [key]: Visit(schema.patternProperties[pattern], references, value[key]) }
            : value;
    }, value);
    if (!IsSchema(schema.additionalProperties)) {
        return Default(schema, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    const unknownProperties = unknownKeys.reduce((value, key) => {
        return !knownKeys.test(key)
            ? { ...value, [key]: Default(additionalProperties, value[key]) }
            : value;
    }, knownProperties);
    return Default(schema, unknownProperties);
}
// prettier-ignore
function FromRef(schema, references, value) {
    const target = Deref(schema, references);
    return Default(schema, Visit(target, references, value));
}
// prettier-ignore
function FromThis(schema, references, value) {
    const target = Deref(schema, references);
    return Default(schema, Visit(target, references, value));
}
// prettier-ignore
function FromTuple(schema, references, value) {
    return (IsArray(value) && IsArray(schema.items))
        ? Default(schema, schema.items.map((schema, index) => Visit(schema, references, value[index])))
        : Default(schema, value);
}
// prettier-ignore
function FromUnion(schema, references, value) {
    for (const subschema of schema.anyOf) {
        if (!Check(subschema, references, value))
            continue;
        // note: ensure interior is decoded first
        const decoded = Visit(subschema, references, value);
        return Default(schema, decoded);
    }
    return Default(schema, value);
}
// prettier-ignore
function Visit(schema, references, value) {
    const references_ = typeof schema.$id === 'string' ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema[Kind]) {
        case 'Array':
            return FromArray(schema_, references_, value);
        case 'Intersect':
            return FromIntersect(schema_, references_, value);
        case 'Not':
            return FromNot(schema_, references_, value);
        case 'Object':
            return FromObject(schema_, references_, value);
        case 'Record':
            return FromRecord(schema_, references_, value);
        case 'Ref':
            return FromRef(schema_, references_, value);
        case 'Symbol':
            return Default(schema_, value);
        case 'This':
            return FromThis(schema_, references_, value);
        case 'Tuple':
            return FromTuple(schema_, references_, value);
        case 'Union':
            return FromUnion(schema_, references_, value);
        default:
            return Default(schema_, value);
    }
}
/**
 * `[Internal]` Decodes the value and returns the result. This function requires that
 * the caller `Check` the value before use. Passing unchecked values may result in
 * undefined behavior. Refer to the `Value.Decode()` for implementation details.
 */
export function TransformDecode(schema, references, value) {
    return Visit(schema, references, value);
}
