"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TransformEncode = exports.TransformEncodeError = exports.TransformEncodeCheckError = void 0;
const index_1 = require("../../type/symbols/index");
const index_2 = require("../../type/error/index");
const index_3 = require("../../type/keyof/index");
const index_4 = require("../../type/indexed/index");
const index_5 = require("../deref/index");
const index_6 = require("../check/index");
// ------------------------------------------------------------------
// ValueGuard
// ------------------------------------------------------------------
const index_7 = require("../guard/index");
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
const type_1 = require("../../type/guard/type");
// ------------------------------------------------------------------
// Errors
// ------------------------------------------------------------------
class TransformEncodeCheckError extends index_2.TypeBoxError {
    constructor(schema, value, error) {
        super(`Unable to encode due to invalid value`);
        this.schema = schema;
        this.value = value;
        this.error = error;
    }
}
exports.TransformEncodeCheckError = TransformEncodeCheckError;
class TransformEncodeError extends index_2.TypeBoxError {
    constructor(schema, value, error) {
        super(`${error instanceof Error ? error.message : 'Unknown error'}`);
        this.schema = schema;
        this.value = value;
    }
}
exports.TransformEncodeError = TransformEncodeError;
// ------------------------------------------------------------------
// Encode
// ------------------------------------------------------------------
// prettier-ignore
function Default(schema, value) {
    try {
        return (0, type_1.IsTransform)(schema) ? schema[index_1.TransformKind].Encode(value) : value;
    }
    catch (error) {
        throw new TransformEncodeError(schema, value, error);
    }
}
// prettier-ignore
function FromArray(schema, references, value) {
    const defaulted = Default(schema, value);
    return (0, index_7.IsArray)(defaulted)
        ? defaulted.map((value) => Visit(schema.items, references, value))
        : defaulted;
}
// prettier-ignore
function FromIntersect(schema, references, value) {
    const defaulted = Default(schema, value);
    if (!(0, index_7.IsPlainObject)(value) || (0, index_7.IsValueType)(value))
        return defaulted;
    const knownKeys = (0, index_3.KeyOfPropertyKeys)(schema);
    const knownProperties = knownKeys.reduce((value, key) => {
        return key in defaulted
            ? { ...value, [key]: Visit((0, index_4.Index)(schema, [key]), references, value[key]) }
            : value;
    }, defaulted);
    if (!(0, type_1.IsTransform)(schema.unevaluatedProperties)) {
        return Default(schema, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const unevaluatedProperties = schema.unevaluatedProperties;
    return unknownKeys.reduce((value, key) => {
        return !knownKeys.includes(key)
            ? { ...value, [key]: Default(unevaluatedProperties, value[key]) }
            : value;
    }, knownProperties);
}
// prettier-ignore
function FromNot(schema, references, value) {
    return Default(schema.not, Default(schema, value));
}
// prettier-ignore
function FromObject(schema, references, value) {
    const defaulted = Default(schema, value);
    if (!(0, index_7.IsPlainObject)(value))
        return defaulted;
    const knownKeys = (0, index_3.KeyOfPropertyKeys)(schema);
    const knownProperties = knownKeys.reduce((value, key) => {
        return key in value
            ? { ...value, [key]: Visit(schema.properties[key], references, value[key]) }
            : value;
    }, defaulted);
    if (!(0, type_1.IsSchema)(schema.additionalProperties)) {
        return knownProperties;
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    return unknownKeys.reduce((value, key) => {
        return !knownKeys.includes(key)
            ? { ...value, [key]: Default(additionalProperties, value[key]) }
            : value;
    }, knownProperties);
}
// prettier-ignore
function FromRecord(schema, references, value) {
    const defaulted = Default(schema, value);
    if (!(0, index_7.IsPlainObject)(value))
        return defaulted;
    const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const knownKeys = new RegExp(pattern);
    const knownProperties = Object.getOwnPropertyNames(value).reduce((value, key) => {
        return knownKeys.test(key)
            ? { ...value, [key]: Visit(schema.patternProperties[pattern], references, value[key]) }
            : value;
    }, defaulted);
    if (!(0, type_1.IsSchema)(schema.additionalProperties)) {
        return Default(schema, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    return unknownKeys.reduce((value, key) => {
        return !knownKeys.test(key)
            ? { ...value, [key]: Default(additionalProperties, value[key]) }
            : value;
    }, knownProperties);
}
// prettier-ignore
function FromRef(schema, references, value) {
    const target = (0, index_5.Deref)(schema, references);
    const resolved = Visit(target, references, value);
    return Default(schema, resolved);
}
// prettier-ignore
function FromThis(schema, references, value) {
    const target = (0, index_5.Deref)(schema, references);
    const resolved = Visit(target, references, value);
    return Default(schema, resolved);
}
// prettier-ignore
function FromTuple(schema, references, value) {
    const value1 = Default(schema, value);
    return (0, index_7.IsArray)(schema.items) ? schema.items.map((schema, index) => Visit(schema, references, value1[index])) : [];
}
// prettier-ignore
function FromUnion(schema, references, value) {
    // test value against union variants
    for (const subschema of schema.anyOf) {
        if (!(0, index_6.Check)(subschema, references, value))
            continue;
        const value1 = Visit(subschema, references, value);
        return Default(schema, value1);
    }
    // test transformed value against union variants
    for (const subschema of schema.anyOf) {
        const value1 = Visit(subschema, references, value);
        if (!(0, index_6.Check)(schema, references, value1))
            continue;
        return Default(schema, value1);
    }
    return Default(schema, value);
}
// prettier-ignore
function Visit(schema, references, value) {
    const references_ = typeof schema.$id === 'string' ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema[index_1.Kind]) {
        case 'Array':
            return FromArray(schema_, references_, value);
        case 'Intersect':
            return FromIntersect(schema_, references_, value);
        case 'Not':
            return FromNot(schema_, references_, value);
        case 'Object':
            return FromObject(schema_, references_, value);
        case 'Record':
            return FromRecord(schema_, references_, value);
        case 'Ref':
            return FromRef(schema_, references_, value);
        case 'This':
            return FromThis(schema_, references_, value);
        case 'Tuple':
            return FromTuple(schema_, references_, value);
        case 'Union':
            return FromUnion(schema_, references_, value);
        default:
            return Default(schema_, value);
    }
}
/**
 * `[Internal]` Encodes the value and returns the result. This function expects the
 * caller to pass a statically checked value. This function does not check the encoded
 * result, meaning the result should be passed to `Check` before use. Refer to the
 * `Value.Encode()` function for implementation details.
 */
function TransformEncode(schema, references, value) {
    return Visit(schema, references, value);
}
exports.TransformEncode = TransformEncode;
