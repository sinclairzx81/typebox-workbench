import { arrayEquals, liftArray, throwParseError } from "@ark/util";
import { Disjoint } from "../shared/disjoint.js";
import { implementNode } from "../shared/implement.js";
import { intersectNodes } from "../shared/intersections.js";
import { $ark, registeredReference } from "../shared/registry.js";
import { hasArkKind } from "../shared/utils.js";
import { BaseRoot } from "./root.js";
import { defineRightwardIntersections } from "./utils.js";
const morphChildKinds = [
    "alias",
    "intersection",
    "unit",
    "domain",
    "proto"
];
const implementation = implementNode({
    kind: "morph",
    hasAssociatedError: false,
    keys: {
        in: {
            child: true,
            parse: (schema, ctx) => ctx.$.node(morphChildKinds, schema)
        },
        morphs: {
            parse: liftArray,
            serialize: morphs => morphs.map(m => hasArkKind(m, "root") ? m.json : registeredReference(m))
        }
    },
    normalize: schema => schema,
    defaults: {
        description: node => `a morph from ${node.in.description} to ${node.out?.description ?? "unknown"}`
    },
    intersections: {
        morph: (l, r, ctx) => {
            if (!l.hasEqualMorphs(r)) {
                return throwParseError(writeMorphIntersectionMessage(l.expression, r.expression));
            }
            const inTersection = intersectNodes(l.in, r.in, ctx);
            if (inTersection instanceof Disjoint)
                return inTersection;
            // in case from is a union, we need to distribute the branches
            // to can be a union as any schema is allowed
            return inTersection.distribute(inBranch => ctx.$.node("morph", {
                morphs: l.morphs,
                in: inBranch
            }), ctx.$.rootNode);
        },
        ...defineRightwardIntersections("morph", (l, r, ctx) => {
            const inTersection = intersectNodes(l.in, r, ctx);
            return inTersection instanceof Disjoint ? inTersection : (inTersection.distribute(branch => ({
                ...l.inner,
                in: branch
            }), ctx.$.rootNode));
        })
    }
});
export class MorphNode extends BaseRoot {
    serializedMorphs = this.morphs.map(registeredReference);
    compiledMorphs = `[${this.serializedMorphs}]`;
    structure = this.in.structure;
    traverseAllows = (data, ctx) => this.in.traverseAllows(data, ctx);
    traverseApply = (data, ctx) => {
        this.in.traverseApply(data, ctx);
        ctx.queueMorphs(this.morphs);
    };
    get shortDescription() {
        return this.in.shortDescription;
    }
    compile(js) {
        if (js.traversalKind === "Allows") {
            js.return(js.invoke(this.in));
            return;
        }
        js.line(js.invoke(this.in));
        js.line(`ctx.queueMorphs(${this.compiledMorphs})`);
    }
    get in() {
        return this.inner.in;
    }
    get out() {
        return this.validatedOut ?? $ark.intrinsic.unknown.internal;
    }
    /** Check if the morphs of r are equal to those of this node */
    hasEqualMorphs(r) {
        return arrayEquals(this.morphs, r.morphs, {
            isEqual: (lMorph, rMorph) => lMorph === rMorph ||
                (hasArkKind(lMorph, "root") &&
                    hasArkKind(rMorph, "root") &&
                    lMorph.equals(rMorph))
        });
    }
    lastMorph = this.inner.morphs.at(-1);
    validatedOut = hasArkKind(this.lastMorph, "root") ?
        Object.assign(this.referencesById, this.lastMorph.out.referencesById) &&
            this.lastMorph.out
        : undefined;
    expression = `(In: ${this.in.expression}) => Out<${this.out.expression}>`;
}
export const Morph = {
    implementation,
    Node: MorphNode
};
export const writeMorphIntersectionMessage = (lDescription, rDescription) => `The intersection of distinct morphs at a single path is indeterminate:
Left: ${lDescription}
Right: ${rDescription}`;
