import { InternalPrimitiveConstraint } from "../constraint.js";
import { Disjoint } from "../shared/disjoint.js";
import { implementNode } from "../shared/implement.js";
import { $ark } from "../shared/registry.js";
const implementation = implementNode({
    kind: "exactLength",
    collapsibleKey: "rule",
    keys: {
        rule: {}
    },
    normalize: schema => typeof schema === "number" ? { rule: schema } : schema,
    hasAssociatedError: true,
    defaults: {
        description: node => `exactly length ${node.rule}`,
        actual: data => `${data.length}`
    },
    intersections: {
        exactLength: (l, r, ctx) => Disjoint.init("unit", ctx.$.node("unit", { unit: l.rule }), ctx.$.node("unit", { unit: r.rule }), { path: ["length"] }),
        minLength: (exactLength, minLength) => (minLength.exclusive ?
            exactLength.rule > minLength.rule
            : exactLength.rule >= minLength.rule) ?
            exactLength
            : Disjoint.init("range", exactLength, minLength),
        maxLength: (exactLength, maxLength) => (maxLength.exclusive ?
            exactLength.rule < maxLength.rule
            : exactLength.rule <= maxLength.rule) ?
            exactLength
            : Disjoint.init("range", exactLength, maxLength)
    }
});
export class ExactLengthNode extends InternalPrimitiveConstraint {
    traverseAllows = data => data.length === this.rule;
    compiledCondition = `data.length === ${this.rule}`;
    compiledNegation = `data.length !== ${this.rule}`;
    impliedBasis = $ark.intrinsic.lengthBoundable.internal;
    expression = `{ length: ${this.rule} }`;
}
export const ExactLength = {
    implementation,
    Node: ExactLengthNode
};
