var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
import { append, cached, flatMorph, printable, spliterate, throwParseError } from "@ark/util";
import { BaseConstraint, constraintKeyParser, flattenConstraints, intersectConstraints } from "../constraint.js";
import { typeOrTermExtends } from "../roots/root.js";
import { Disjoint } from "../shared/disjoint.js";
import { implementNode } from "../shared/implement.js";
import { intersectNodesRoot } from "../shared/intersections.js";
import { $ark, registeredReference } from "../shared/registry.js";
import { hasArkKind, makeRootAndArrayPropertiesMutable } from "../shared/utils.js";
import { arrayIndexMatcherReference } from "./shared.js";
const createStructuralWriter = (childStringProp) => (node) => {
    if (node.props.length || node.index) {
        const parts = node.index?.map(String) ?? [];
        node.props.forEach(node => parts.push(node[childStringProp]));
        if (node.undeclared)
            parts.push(`+ (undeclared): ${node.undeclared}`);
        const objectLiteralDescription = `{ ${parts.join(", ")} }`;
        return node.sequence ?
            `${objectLiteralDescription} & ${node.sequence.description}`
            : objectLiteralDescription;
    }
    return node.sequence?.description ?? "{}";
};
const structuralDescription = createStructuralWriter("description");
const structuralExpression = createStructuralWriter("expression");
const implementation = implementNode({
    kind: "structure",
    hasAssociatedError: false,
    normalize: schema => schema,
    keys: {
        required: {
            child: true,
            parse: constraintKeyParser("required")
        },
        optional: {
            child: true,
            parse: constraintKeyParser("optional")
        },
        index: {
            child: true,
            parse: constraintKeyParser("index")
        },
        sequence: {
            child: true,
            parse: constraintKeyParser("sequence")
        },
        undeclared: {
            parse: behavior => (behavior === "ignore" ? undefined : behavior)
        }
    },
    defaults: {
        description: structuralDescription
    },
    intersections: {
        structure: (l, r, ctx) => {
            const lInner = { ...l.inner };
            const rInner = { ...r.inner };
            if (l.undeclared) {
                const lKey = l.keyof();
                const disjointRKeys = r.requiredLiteralKeys.filter(k => !lKey.allows(k));
                if (disjointRKeys.length) {
                    return new Disjoint(...disjointRKeys.map(k => ({
                        kind: "presence",
                        l: $ark.intrinsic.never.internal,
                        r: r.propsByKey[k].value,
                        path: [k],
                        optional: false
                    })));
                }
                if (rInner.optional)
                    rInner.optional = rInner.optional.filter(n => lKey.allows(n.key));
                if (rInner.index) {
                    rInner.index = rInner.index.flatMap(n => {
                        if (n.signature.extends(lKey))
                            return n;
                        const indexOverlap = intersectNodesRoot(lKey, n.signature, ctx.$);
                        if (indexOverlap instanceof Disjoint)
                            return [];
                        const normalized = normalizeIndex(indexOverlap, n.value, ctx.$);
                        if (normalized.required) {
                            rInner.required =
                                rInner.required ?
                                    [...rInner.required, ...normalized.required]
                                    : normalized.required;
                        }
                        return normalized.index ?? [];
                    });
                }
            }
            if (r.undeclared) {
                const rKey = r.keyof();
                const disjointLKeys = l.requiredLiteralKeys.filter(k => !rKey.allows(k));
                if (disjointLKeys.length) {
                    return new Disjoint(...disjointLKeys.map(k => ({
                        kind: "presence",
                        l: l.propsByKey[k].value,
                        r: $ark.intrinsic.never.internal,
                        path: [k],
                        optional: false
                    })));
                }
                if (lInner.optional)
                    lInner.optional = lInner.optional.filter(n => rKey.allows(n.key));
                if (lInner.index) {
                    lInner.index = lInner.index.flatMap(n => {
                        if (n.signature.extends(rKey))
                            return n;
                        const indexOverlap = intersectNodesRoot(rKey, n.signature, ctx.$);
                        if (indexOverlap instanceof Disjoint)
                            return [];
                        const normalized = normalizeIndex(indexOverlap, n.value, ctx.$);
                        if (normalized.required) {
                            lInner.required =
                                lInner.required ?
                                    [...lInner.required, ...normalized.required]
                                    : normalized.required;
                        }
                        return normalized.index ?? [];
                    });
                }
            }
            const baseInner = {};
            if (l.undeclared || r.undeclared) {
                baseInner.undeclared =
                    l.undeclared === "reject" || r.undeclared === "reject" ?
                        "reject"
                        : "delete";
            }
            return intersectConstraints({
                kind: "structure",
                baseInner,
                l: flattenConstraints(lInner),
                r: flattenConstraints(rInner),
                roots: [],
                ctx
            });
        }
    }
});
let StructureNode = (() => {
    let _classSuper = BaseConstraint;
    let _instanceExtraInitializers = [];
    let _keyof_decorators;
    return class StructureNode extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _keyof_decorators = [cached];
            __esDecorate(this, null, _keyof_decorators, { kind: "method", name: "keyof", static: false, private: false, access: { has: obj => "keyof" in obj, get: obj => obj.keyof }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        impliedBasis = (__runInitializers(this, _instanceExtraInitializers), $ark.intrinsic.object.internal);
        impliedSiblings = this.children.flatMap(n => n.impliedSiblings ?? []);
        props = this.required ?
            this.optional ?
                [...this.required, ...this.optional]
                : this.required
            : (this.optional ?? []);
        propsByKey = flatMorph(this.props, (i, node) => [node.key, node]);
        propsByKeyReference = registeredReference(this.propsByKey);
        expression = structuralExpression(this);
        requiredLiteralKeys = this.required?.map(node => node.key) ?? [];
        optionalLiteralKeys = this.optional?.map(node => node.key) ?? [];
        literalKeys = [
            ...this.requiredLiteralKeys,
            ...this.optionalLiteralKeys
        ];
        keyof() {
            let branches = this.$.units(this.literalKeys).branches;
            this.index?.forEach(({ signature }) => {
                branches = branches.concat(signature.branches);
            });
            return this.$.node("union", branches);
        }
        assertHasKeys(keys) {
            const invalidKeys = keys.filter(k => !typeOrTermExtends(k, this.keyof()));
            if (invalidKeys.length) {
                return throwParseError(writeInvalidKeysMessage(this.expression, invalidKeys));
            }
        }
        get(indexer, ...path) {
            let value;
            let required = false;
            const key = indexerToKey(indexer);
            if ((typeof key === "string" || typeof key === "symbol") &&
                this.propsByKey[key]) {
                value = this.propsByKey[key].value;
                required = this.propsByKey[key].required;
            }
            this.index?.forEach(n => {
                if (typeOrTermExtends(key, n.signature))
                    value = value?.and(n.value) ?? n.value;
            });
            if (this.sequence &&
                typeOrTermExtends(key, $ark.intrinsic.nonNegativeIntegerString)) {
                if (hasArkKind(key, "root")) {
                    if (this.sequence.variadic)
                        // if there is a variadic element and we're accessing an index, return a union
                        // of all possible elements. If there is no variadic expression, we're in a tuple
                        // so this access wouldn't be safe based on the array indices
                        value = value?.and(this.sequence.element) ?? this.sequence.element;
                }
                else {
                    const index = Number.parseInt(key);
                    if (index < this.sequence.prevariadic.length) {
                        const fixedElement = this.sequence.prevariadic[index];
                        value = value?.and(fixedElement) ?? fixedElement;
                        required ||= index < this.sequence.prefix.length;
                    }
                    else if (this.sequence.variadic) {
                        // ideally we could return something more specific for postfix
                        // but there is no way to represent it using an index alone
                        const nonFixedElement = this.$.node("union", this.sequence.variadicOrPostfix);
                        value = value?.and(nonFixedElement) ?? nonFixedElement;
                    }
                }
            }
            if (!value) {
                if (this.sequence?.variadic &&
                    hasArkKind(key, "root") &&
                    key.extends($ark.intrinsic.number)) {
                    return throwParseError(writeNumberIndexMessage(key.expression, this.sequence.expression));
                }
                return throwParseError(writeInvalidKeysMessage(this.expression, [key]));
            }
            const result = value.get(...path);
            return required ? result : result.or($ark.intrinsic.undefined);
        }
        exhaustive = this.undeclared !== undefined || this.index !== undefined;
        pick(...keys) {
            this.assertHasKeys(keys);
            return this.$.node("structure", this.filterKeys("pick", keys));
        }
        omit(...keys) {
            this.assertHasKeys(keys);
            return this.$.node("structure", this.filterKeys("omit", keys));
        }
        optionalize() {
            const { required, ...inner } = this.inner;
            return this.$.node("structure", {
                ...inner,
                optional: this.props.map(prop => prop.hasKind("required") ? this.$.node("optional", prop.inner) : prop)
            });
        }
        require() {
            const { optional, ...inner } = this.inner;
            return this.$.node("structure", {
                ...inner,
                required: this.props.map(prop => prop.hasKind("optional") ?
                    // don't include keys like default that don't exist on required
                    this.$.node("required", { key: prop.key, value: prop.value })
                    : prop)
            });
        }
        merge(r) {
            const inner = this.filterKeys("omit", [r.keyof()]);
            if (r.required)
                inner.required = append(inner.required, r.required);
            if (r.optional)
                inner.optional = append(inner.optional, r.optional);
            if (r.index)
                inner.index = append(inner.index, r.index);
            if (r.sequence)
                inner.sequence = r.sequence;
            if (r.undeclared)
                inner.undeclared = r.undeclared;
            else
                delete inner.undeclared;
            return this.$.node("structure", inner);
        }
        filterKeys(operation, keys) {
            const result = makeRootAndArrayPropertiesMutable(this.inner);
            const shouldKeep = (key) => {
                const matchesKey = keys.some(k => typeOrTermExtends(key, k));
                return operation === "pick" ? matchesKey : !matchesKey;
            };
            if (result.required)
                result.required = result.required.filter(prop => shouldKeep(prop.key));
            if (result.optional)
                result.optional = result.optional.filter(prop => shouldKeep(prop.key));
            if (result.index)
                result.index = result.index.filter(index => shouldKeep(index.signature));
            return result;
        }
        traverseAllows = (data, ctx) => this._traverse("Allows", data, ctx);
        traverseApply = (data, ctx) => this._traverse("Apply", data, ctx);
        _traverse = (traversalKind, data, ctx) => {
            const errorCount = ctx?.currentErrorCount ?? 0;
            for (let i = 0; i < this.props.length; i++) {
                if (traversalKind === "Allows") {
                    if (!this.props[i].traverseAllows(data, ctx))
                        return false;
                }
                else {
                    this.props[i].traverseApply(data, ctx);
                    if (ctx.failFast && ctx.currentErrorCount > errorCount)
                        return false;
                }
            }
            if (this.sequence) {
                if (traversalKind === "Allows") {
                    if (!this.sequence.traverseAllows(data, ctx))
                        return false;
                }
                else {
                    this.sequence.traverseApply(data, ctx);
                    if (ctx.failFast && ctx.currentErrorCount > errorCount)
                        return false;
                }
            }
            if (!this.exhaustive)
                return true;
            const keys = Object.keys(data);
            keys.push(...Object.getOwnPropertySymbols(data));
            for (let i = 0; i < keys.length; i++) {
                const k = keys[i];
                let matched = false;
                if (this.index) {
                    for (const node of this.index) {
                        if (node.signature.traverseAllows(k, ctx)) {
                            if (traversalKind === "Allows") {
                                ctx?.path.push(k);
                                const result = node.value.traverseAllows(data[k], ctx);
                                ctx?.path.pop();
                                if (!result)
                                    return false;
                            }
                            else {
                                ctx.path.push(k);
                                node.value.traverseApply(data[k], ctx);
                                ctx.path.pop();
                                if (ctx.failFast && ctx.currentErrorCount > errorCount)
                                    return false;
                            }
                            matched = true;
                        }
                    }
                }
                if (this.undeclared) {
                    matched ||= k in this.propsByKey;
                    matched ||=
                        this.sequence !== undefined &&
                            typeof k === "string" &&
                            $ark.intrinsic.nonNegativeIntegerString.allows(k);
                    if (!matched) {
                        if (traversalKind === "Allows")
                            return false;
                        if (this.undeclared === "reject")
                            ctx.error({ expected: "removed", actual: null, relativePath: [k] });
                        else {
                            ctx.queueMorphs([
                                data => {
                                    delete data[k];
                                    return data;
                                }
                            ]);
                        }
                        if (ctx.failFast)
                            return false;
                    }
                }
                ctx?.path.pop();
            }
            return true;
        };
        compile(js) {
            if (js.traversalKind === "Apply")
                js.initializeErrorCount();
            this.props.forEach(prop => {
                js.check(prop);
                if (js.traversalKind === "Apply")
                    js.returnIfFailFast();
            });
            if (this.sequence) {
                js.check(this.sequence);
                if (js.traversalKind === "Apply")
                    js.returnIfFailFast();
            }
            if (this.exhaustive) {
                js.const("keys", "Object.keys(data)");
                js.line("keys.push(...Object.getOwnPropertySymbols(data))");
                js.for("i < keys.length", () => this.compileExhaustiveEntry(js));
            }
            if (js.traversalKind === "Allows")
                js.return(true);
        }
        compileExhaustiveEntry(js) {
            js.const("k", "keys[i]");
            if (this.undeclared)
                js.let("matched", false);
            this.index?.forEach(node => {
                js.if(`${js.invoke(node.signature, { arg: "k", kind: "Allows" })}`, () => {
                    js.traverseKey("k", "data[k]", node.value);
                    if (this.undeclared)
                        js.set("matched", true);
                    return js;
                });
            });
            if (this.undeclared) {
                if (this.props?.length !== 0)
                    js.line(`matched ||= k in ${this.propsByKeyReference}`);
                if (this.sequence) {
                    js.line(`matched ||= typeof k === "string" && ${arrayIndexMatcherReference}.test(k)`);
                }
                js.if("!matched", () => {
                    if (js.traversalKind === "Allows")
                        return js.return(false);
                    return this.undeclared === "reject" ?
                        js
                            .line(`ctx.error({ expected: "removed", actual: null, relativePath: [k] })`)
                            .if("ctx.failFast", () => js.return())
                        : js.line(`ctx.queueMorphs([data => { delete data[k]; return data }])`);
                });
            }
            return js;
        }
    };
})();
export { StructureNode };
export const Structure = {
    implementation,
    Node: StructureNode
};
const indexerToKey = (indexable) => {
    if (hasArkKind(indexable, "root") && indexable.hasKind("unit"))
        indexable = indexable.unit;
    if (typeof indexable === "number")
        indexable = `${indexable}`;
    return indexable;
};
export const writeNumberIndexMessage = (indexExpression, sequenceExpression) => `${indexExpression} is not allowed as an array index on ${sequenceExpression}. Use the 'nonNegativeIntegerString' keyword instead.`;
/** extract enumerable named props from an index signature */
export const normalizeIndex = (signature, value, $) => {
    const [enumerableBranches, nonEnumerableBranches] = spliterate(signature.branches, k => k.hasKind("unit"));
    if (!enumerableBranches.length)
        return { index: $.node("index", { signature, value }) };
    const normalized = {};
    normalized.required = enumerableBranches.map(n => $.node("required", { key: n.unit, value }));
    if (nonEnumerableBranches.length) {
        normalized.index = $.node("index", {
            signature: nonEnumerableBranches,
            value
        });
    }
    return normalized;
};
export const typeKeyToString = (k) => hasArkKind(k, "root") ? k.expression : printable(k);
export const writeInvalidKeysMessage = (o, keys) => `Key${keys.length === 1 ? "" : "s"} ${keys.map(typeKeyToString).join(", ")} ${keys.length === 1 ? "does" : "do"} not exist on ${o}`;
