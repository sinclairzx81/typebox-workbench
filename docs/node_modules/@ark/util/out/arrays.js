export const join = (segments, delimiter) => segments.join(delimiter);
export const getPath = (root, path) => {
    let result = root;
    for (const segment of path) {
        if (typeof result !== "object" || result === null)
            return undefined;
        result = result[segment];
    }
    return result;
};
export const intersectUniqueLists = (l, r) => {
    const intersection = [...l];
    for (const item of r)
        if (!l.includes(item))
            intersection.push(item);
    return intersection;
};
export const liftArray = (data) => (Array.isArray(data) ? data : [data]);
export const spliterate = (list, by) => {
    const result = [[], []];
    for (const item of list) {
        if (by(item))
            result[0].push(item);
        else
            result[1].push(item);
    }
    return result;
};
export const ReadonlyArray = Array;
export const includes = (array, element) => array.includes(element);
export const range = (length, offset = 0) => [...new Array(length)].map((_, i) => i + offset);
/**
 * Adds a value or array to an array, returning the concatenated result
 *
 * @param to The array to which `value` is to be added. If `to` is `undefined`, a new array
 * is created as `[value]` if value was not undefined, otherwise `[]`.
 * @param value The value to add to the array.
 * @param opts
 * 		prepend: If true, adds the element to the beginning of the array instead of the end
 */
export const append = (to, value, opts) => {
    if (to === undefined) {
        return (value === undefined ? []
            : Array.isArray(value) ? value
                : [value]);
    }
    if (opts?.prepend)
        Array.isArray(value) ? to.unshift(...value) : to.unshift(value);
    else
        Array.isArray(value) ? to.push(...value) : to.push(value);
    return to;
};
/**
 * Concatenates an element or list with a readonly list
 *
 * @param {to} to - The base list.
 * @param {elementOrList} elementOrList - The element or list to concatenate.
 */
export const conflatenate = (to, elementOrList) => {
    if (elementOrList === undefined || elementOrList === null)
        return to ?? [];
    if (to === undefined || to === null)
        return liftArray(elementOrList);
    return to.concat(elementOrList);
};
/**
 * Concatenates a variadic list of elements or lists with a readonly list
 *
 * @param {to} to - The base list.
 * @param {elementsOrLists} elementsOrLists - The elements or lists to concatenate.
 */
export const conflatenateAll = (...elementsOrLists) => elementsOrLists.reduce(conflatenate, []);
/**
 * Appends a value or concatenates an array to an array if it is not already included, returning the array
 *
 * @param to The array to which `value` is to be appended. If `to` is `undefined`, a new array
 * is created including only `value`.
 * @param value An array or value to append to the array. If `to` includes `value`, nothing is appended.
 */
export const appendUnique = (to, value, opts) => {
    if (to === undefined)
        return Array.isArray(value) ? value : [value];
    const isEqual = opts?.isEqual ?? ((l, r) => l === r);
    liftArray(value).forEach(v => {
        if (!to.some(existing => isEqual(existing, v)))
            to.push(v);
    });
    return to;
};
export const groupBy = (array, discriminant) => array.reduce((result, item) => {
    const key = item[discriminant];
    result[key] = append(result[key], item);
    return result;
}, {});
export const arrayEquals = (l, r, opts) => l.length === r.length &&
    l.every(opts?.isEqual ?
        (lItem, i) => opts.isEqual(lItem, r[i])
        : (lItem, i) => lItem === r[i]);
