/**
 * This module provides utility functions for working with Iterables in TypeScript.
 *
 * @since 2.0.0
 */
import type { NonEmptyArray } from "./Array.js";
import type { Either } from "./Either.js";
import type { Option } from "./Option.js";
import type * as Record from "./Record.js";
import type { NoInfer } from "./Types.js";
/**
 * Return a `Iterable` with element `i` initialized with `f(i)`.
 *
 * If the `length` is not specified, the `Iterable` will be infinite.
 *
 * **Note**. `length` is normalized to an integer >= 1.
 *
 * @example
 * import { makeBy } from 'effect/Iterable'
 *
 * assert.deepStrictEqual(Array.from(makeBy(n => n * 2, { length: 5 })), [0, 2, 4, 6, 8])
 *
 * @category constructors
 * @since 2.0.0
 */
export declare const makeBy: <A>(f: (i: number) => A, options?: {
    readonly length?: number;
}) => Iterable<A>;
/**
 * Return a `Iterable` containing a range of integers, including both endpoints.
 *
 * If `end` is omitted, the range will not have an upper bound.
 *
 * @example
 * import { range } from 'effect/Iterable'
 *
 * assert.deepStrictEqual(Array.from(range(1, 3)), [1, 2, 3])
 *
 * @category constructors
 * @since 2.0.0
 */
export declare const range: (start: number, end?: number) => Iterable<number>;
/**
 * Return a `Iterable` containing a value repeated the specified number of times.
 *
 * **Note**. `n` is normalized to an integer >= 1.
 *
 * @example
 * import { replicate } from 'effect/Iterable'
 *
 * assert.deepStrictEqual(Array.from(replicate("a", 3)), ["a", "a", "a"])
 *
 * @category constructors
 * @since 2.0.0
 */
export declare const replicate: {
    (n: number): <A>(a: A) => Iterable<A>;
    <A>(a: A, n: number): Iterable<A>;
};
/**
 * Takes a record and returns an Iterable of tuples containing its keys and values.
 *
 * @param self - The record to transform.
 *
 * @example
 * import { fromRecord } from "effect/Iterable"
 *
 * const x = { a: 1, b: 2, c: 3 }
 * assert.deepStrictEqual(Array.from(fromRecord(x)), [["a", 1], ["b", 2], ["c", 3]])
 *
 * @category conversions
 * @since 2.0.0
 */
export declare const fromRecord: <K extends string, A>(self: Readonly<Record<K, A>>) => Iterable<[K, A]>;
/**
 * Prepend an element to the front of an `Iterable`, creating a new `Iterable`.
 *
 * @category concatenating
 * @since 2.0.0
 */
export declare const prepend: {
    <B>(head: B): <A>(self: Iterable<A>) => Iterable<A | B>;
    <A, B>(self: Iterable<A>, head: B): Iterable<A | B>;
};
/**
 * Prepends the specified prefix iterable to the beginning of the specified iterable.
 *
 * @example
 * import * as Iterable from "effect/Iterable"
 *
 * assert.deepStrictEqual(
 *   Array.from(Iterable.prependAll([1, 2], ["a", "b"])),
 *   ["a", "b", 1, 2]
 * )
 *
 * @category concatenating
 * @since 2.0.0
 */
export declare const prependAll: {
    <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<A | B>;
    <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<A | B>;
};
/**
 * Append an element to the end of an `Iterable`, creating a new `Iterable`.
 *
 * @category concatenating
 * @since 2.0.0
 */
export declare const append: {
    <B>(last: B): <A>(self: Iterable<A>) => Iterable<A | B>;
    <A, B>(self: Iterable<A>, last: B): Iterable<A | B>;
};
/**
 * Concatenates two iterables, combining their elements.
 *
 * @category concatenating
 * @since 2.0.0
 */
export declare const appendAll: {
    <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<A | B>;
    <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<A | B>;
};
/**
 * Reduce an `Iterable` from the left, keeping all intermediate results instead of only the final result.
 *
 * @category folding
 * @since 2.0.0
 */
export declare const scan: {
    <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<A>) => Iterable<B>;
    <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): Iterable<B>;
};
/**
 * Determine if an `Iterable` is empty
 *
 * @example
 * import { isEmpty } from "effect/Iterable"
 *
 * assert.deepStrictEqual(isEmpty([]), true);
 * assert.deepStrictEqual(isEmpty([1, 2, 3]), false);
 *
 * @category guards
 * @since 2.0.0
 */
export declare const isEmpty: <A>(self: Iterable<A>) => self is Iterable<never>;
/**
 * Return the number of elements in a `Iterable`.
 *
 * @category getters
 * @since 2.0.0
 */
export declare const size: <A>(self: Iterable<A>) => number;
/**
 * Get the first element of a `Iterable`, or `None` if the `Iterable` is empty.
 *
 * @category getters
 * @since 2.0.0
 */
export declare const head: <A>(self: Iterable<A>) => Option<A>;
/**
 * Keep only a max number of elements from the start of an `Iterable`, creating a new `Iterable`.
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @category getters
 * @since 2.0.0
 */
export declare const take: {
    (n: number): <A>(self: Iterable<A>) => Iterable<A>;
    <A>(self: Iterable<A>, n: number): Iterable<A>;
};
/**
 * Calculate the longest initial Iterable for which all element satisfy the specified predicate, creating a new `Iterable`.
 *
 * @category getters
 * @since 2.0.0
 */
export declare const takeWhile: {
    <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Iterable<B>;
    <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Iterable<A>;
    <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Iterable<B>;
    <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Iterable<A>;
};
/**
 * Drop a max number of elements from the start of an `Iterable`
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @category getters
 * @since 2.0.0
 */
export declare const drop: {
    (n: number): <A>(self: Iterable<A>) => Iterable<A>;
    <A>(self: Iterable<A>, n: number): Iterable<A>;
};
/**
 * Returns the first element that satisfies the specified
 * predicate, or `None` if no such element exists.
 *
 * @category elements
 * @since 2.0.0
 */
export declare const findFirst: {
    <A, B>(f: (a: NoInfer<A>, i: number) => Option<B>): (self: Iterable<A>) => Option<B>;
    <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option<B>;
    <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<A>;
    <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Option<B>;
    <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option<B>;
    <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<A>;
};
/**
 * Find the last element for which a predicate holds.
 *
 * @category elements
 * @since 2.0.0
 */
export declare const findLast: {
    <A, B>(f: (a: NoInfer<A>, i: number) => Option<B>): (self: Iterable<A>) => Option<B>;
    <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option<B>;
    <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<A>;
    <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Option<B>;
    <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option<B>;
    <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<A>;
};
/**
 * Takes two `Iterable`s and returns an `Iterable` of corresponding pairs.
 *
 * @category zipping
 * @since 2.0.0
 */
export declare const zip: {
    <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<[A, B]>;
    <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<[A, B]>;
};
/**
 * Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results. If one
 * input `Iterable` is short, excess elements of the longer `Iterable` are discarded.
 *
 * @category zipping
 * @since 2.0.0
 */
export declare const zipWith: {
    <B, A, C>(that: Iterable<B>, f: (a: A, b: B) => C): (self: Iterable<A>) => Iterable<C>;
    <A, B, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Iterable<C>;
};
/**
 * Places an element in between members of an `Iterable`.
 * If the input is a non-empty array, the result is also a non-empty array.
 *
 * @since 2.0.0
 */
export declare const intersperse: {
    <B>(middle: B): <A>(self: Iterable<A>) => Iterable<A | B>;
    <A, B>(self: Iterable<A>, middle: B): Iterable<A | B>;
};
/**
 * Returns a function that checks if an `Iterable` contains a given value using a provided `isEquivalent` function.
 *
 * @category elements
 * @since 2.0.0
 */
export declare const containsWith: <A>(isEquivalent: (self: A, that: A) => boolean) => {
    (a: A): (self: Iterable<A>) => boolean;
    (self: Iterable<A>, a: A): boolean;
};
/**
 * Returns a function that checks if a `Iterable` contains a given value using the default `Equivalence`.
 *
 * @category elements
 * @since 2.0.0
 */
export declare const contains: {
    <A>(a: A): (self: Iterable<A>) => boolean;
    <A>(self: Iterable<A>, a: A): boolean;
};
/**
 * Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of
 * the `Iterable`.
 *
 * @category splitting
 * @since 2.0.0
 */
export declare const chunksOf: {
    (n: number): <A>(self: Iterable<A>) => Iterable<Array<A>>;
    <A>(self: Iterable<A>, n: number): Iterable<Array<A>>;
};
/**
 * Group equal, consecutive elements of an `Iterable` into `NonEmptyArray`s using the provided `isEquivalent` function.
 *
 * @category grouping
 * @since 2.0.0
 */
export declare const groupWith: {
    <A>(isEquivalent: (self: A, that: A) => boolean): (self: Iterable<A>) => Iterable<NonEmptyArray<A>>;
    <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Iterable<NonEmptyArray<A>>;
};
/**
 * Group equal, consecutive elements of an `Iterable` into `NonEmptyArray`s.
 *
 * @category grouping
 * @since 2.0.0
 */
export declare const group: <A>(self: Iterable<A>) => Iterable<NonEmptyArray<A>>;
/**
 * Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning
 * function on each element, and grouping the results according to values returned
 *
 * @category grouping
 * @since 2.0.0
 */
export declare const groupBy: {
    <A, K extends string | symbol>(f: (a: A) => K): (self: Iterable<A>) => Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>;
    <A, K extends string | symbol>(self: Iterable<A>, f: (a: A) => K): Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>;
};
/**
 * @category constructors
 * @since 2.0.0
 */
export declare const empty: <A = never>() => Iterable<A>;
/**
 * Constructs a new `Iterable<A>` from the specified value.
 *
 * @category constructors
 * @since 2.0.0
 */
export declare const of: <A>(a: A) => Iterable<A>;
/**
 * @category mapping
 * @since 2.0.0
 */
export declare const map: {
    <A, B>(f: (a: NoInfer<A>, i: number) => B): (self: Iterable<A>) => Iterable<B>;
    <A, B>(self: Iterable<A>, f: (a: NoInfer<A>, i: number) => B): Iterable<B>;
};
/**
 * Applies a function to each element in an Iterable and returns a new Iterable containing the concatenated mapped elements.
 *
 * @category sequencing
 * @since 2.0.0
 */
export declare const flatMap: {
    <A, B>(f: (a: NoInfer<A>, i: number) => Iterable<B>): (self: Iterable<A>) => Iterable<B>;
    <A, B>(self: Iterable<A>, f: (a: NoInfer<A>, i: number) => Iterable<B>): Iterable<B>;
};
/**
 * Flattens an Iterable of Iterables into a single Iterable
 *
 * @category sequencing
 * @since 2.0.0
 */
export declare const flatten: <A>(self: Iterable<Iterable<A>>) => Iterable<A>;
/**
 * @category filtering
 * @since 2.0.0
 */
export declare const filterMap: {
    <A, B>(f: (a: A, i: number) => Option<B>): (self: Iterable<A>) => Iterable<B>;
    <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Iterable<B>;
};
/**
 * Transforms all elements of the `Iterable` for as long as the specified function returns some value
 *
 * @category filtering
 * @since 2.0.0
 */
export declare const filterMapWhile: {
    <A, B>(f: (a: A, i: number) => Option<B>): (self: Iterable<A>) => Iterable<B>;
    <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Iterable<B>;
};
/**
 * Retrieves the `Some` values from an `Iterable` of `Option`s.
 *
 * @example
 * import { getSomes } from "effect/Iterable"
 * import { some, none } from "effect/Option"
 *
 * assert.deepStrictEqual(
 *   Array.from(getSomes([some(1), none(), some(2)])),
 *   [1, 2]
 * )
 *
 * @category filtering
 * @since 2.0.0
 */
export declare const getSomes: <A>(self: Iterable<Option<A>>) => Iterable<A>;
/**
 * Retrieves the `Left` values from an `Iterable` of `Either`s.
 *
 * @example
 * import { getLefts } from "effect/Iterable"
 * import { right, left } from "effect/Either"
 *
 * assert.deepStrictEqual(
 *   Array.from(getLefts([right(1), left("err"), right(2)])),
 *   ["err"]
 * )
 *
 * @category filtering
 * @since 2.0.0
 */
export declare const getLefts: <R, L>(self: Iterable<Either<R, L>>) => Iterable<L>;
/**
 * Retrieves the `Right` values from an `Iterable` of `Either`s.
 *
 * @example
 * import { getRights } from "effect/Iterable"
 * import { right, left } from "effect/Either"
 *
 * assert.deepStrictEqual(
 *   Array.from(getRights([right(1), left("err"), right(2)])),
 *   [1, 2]
 * )
 *
 * @category filtering
 * @since 2.0.0
 */
export declare const getRights: <R, L>(self: Iterable<Either<R, L>>) => Iterable<R>;
/**
 * @category filtering
 * @since 2.0.0
 */
export declare const filter: {
    <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Iterable<B>;
    <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Iterable<A>;
    <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Iterable<B>;
    <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Iterable<A>;
};
/**
 * @category sequencing
 * @since 2.0.0
 */
export declare const flatMapNullable: {
    <A, B>(f: (a: A) => B | null | undefined): (self: Iterable<A>) => Iterable<NonNullable<B>>;
    <A, B>(self: Iterable<A>, f: (a: A) => B | null | undefined): Iterable<NonNullable<B>>;
};
/**
 * Check if a predicate holds true for some `Iterable` element.
 *
 * @category elements
 * @since 2.0.0
 */
export declare const some: {
    <A>(predicate: (a: A, i: number) => boolean): (self: Iterable<A>) => boolean;
    <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): boolean;
};
/**
 * @category constructors
 * @since 2.0.0
 */
export declare const unfold: <B, A>(b: B, f: (b: B) => Option<readonly [A, B]>) => Iterable<A>;
/**
 * Iterate over the `Iterable` applying `f`.
 *
 * @since 2.0.0
 */
export declare const forEach: {
    <A>(f: (a: A, i: number) => void): (self: Iterable<A>) => void;
    <A>(self: Iterable<A>, f: (a: A, i: number) => void): void;
};
/**
 * @category folding
 * @since 2.0.0
 */
export declare const reduce: {
    <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Iterable<A>) => B;
    <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B;
};
/**
 * Deduplicates adjacent elements that are identical using the provided `isEquivalent` function.
 *
 * @since 2.0.0
 */
export declare const dedupeAdjacentWith: {
    <A>(isEquivalent: (self: A, that: A) => boolean): (self: Iterable<A>) => Iterable<A>;
    <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Iterable<A>;
};
/**
 * Deduplicates adjacent elements that are identical.
 *
 * @since 2.0.0
 */
export declare const dedupeAdjacent: <A>(self: Iterable<A>) => Iterable<A>;
/**
 * Zips this Iterable crosswise with the specified Iterable using the specified combiner.
 *
 * @since 2.0.0
 * @category elements
 */
export declare const cartesianWith: {
    <A, B, C>(that: Iterable<B>, f: (a: A, b: B) => C): (self: Iterable<A>) => Iterable<C>;
    <A, B, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Iterable<C>;
};
/**
 * Zips this Iterable crosswise with the specified Iterable.
 *
 * @since 2.0.0
 * @category elements
 */
export declare const cartesian: {
    <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<[A, B]>;
    <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<[A, B]>;
};
//# sourceMappingURL=Iterable.d.ts.map