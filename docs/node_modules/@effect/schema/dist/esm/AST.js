/**
 * @since 1.0.0
 */
import * as Arr from "effect/Array";
import { dual, identity } from "effect/Function";
import { globalValue } from "effect/GlobalValue";
import * as Hash from "effect/Hash";
import * as Number from "effect/Number";
import * as Option from "effect/Option";
import * as Order from "effect/Order";
import * as Predicate from "effect/Predicate";
import * as regexp from "effect/RegExp";
import * as errors_ from "./internal/errors.js";
import * as util_ from "./internal/util.js";
/**
 * @category annotations
 * @since 1.0.0
 */
export const BrandAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Brand");
/**
 * @category annotations
 * @since 1.0.0
 */
export const TypeAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Type");
/**
 * @category annotations
 * @since 1.0.0
 */
export const MessageAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Message");
/**
 * @category annotations
 * @since 1.0.0
 */
export const IdentifierAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Identifier");
/**
 * @category annotations
 * @since 1.0.0
 */
export const TitleAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Title");
/**
 * @category annotations
 * @since 1.0.0
 */
export const DescriptionAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Description");
/**
 * @category annotations
 * @since 1.0.0
 */
export const ExamplesAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Examples");
/**
 * @category annotations
 * @since 1.0.0
 */
export const DefaultAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Default");
/**
 * @category annotations
 * @since 1.0.0
 */
export const JSONSchemaAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/JSONSchema");
/**
 * @category annotations
 * @since 1.0.0
 */
export const DocumentationAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Documentation");
/**
 * @category annotations
 * @since 1.0.0
 */
export const ConcurrencyAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Concurrency");
/**
 * @category annotations
 * @since 1.0.0
 */
export const BatchingAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Batching");
/** @internal */
export const SurrogateAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Surrogate");
/**
 * @category annotations
 * @since 1.0.0
 */
export const ParseIssueTitleAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/ParseIssueTitle");
/**
 * @category annotations
 * @since 1.0.0
 */
export const getAnnotation = /*#__PURE__*/dual(2, (annotated, key) => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? Option.some(annotated.annotations[key]) : Option.none());
/**
 * @category annotations
 * @since 1.0.0
 */
export const getBrandAnnotation = /*#__PURE__*/getAnnotation(BrandAnnotationId);
/**
 * @category annotations
 * @since 1.0.0
 */
export const getMessageAnnotation = /*#__PURE__*/getAnnotation(MessageAnnotationId);
/**
 * @category annotations
 * @since 1.0.0
 */
export const getTitleAnnotation = /*#__PURE__*/getAnnotation(TitleAnnotationId);
/**
 * @category annotations
 * @since 1.0.0
 */
export const getIdentifierAnnotation = /*#__PURE__*/getAnnotation(IdentifierAnnotationId);
/**
 * @category annotations
 * @since 1.0.0
 */
export const getDescriptionAnnotation = /*#__PURE__*/getAnnotation(DescriptionAnnotationId);
/**
 * @category annotations
 * @since 1.0.0
 */
export const getExamplesAnnotation = /*#__PURE__*/getAnnotation(ExamplesAnnotationId);
/**
 * @category annotations
 * @since 1.0.0
 */
export const getDefaultAnnotation = /*#__PURE__*/getAnnotation(DefaultAnnotationId);
/**
 * @category annotations
 * @since 1.0.0
 */
export const getJSONSchemaAnnotation = /*#__PURE__*/getAnnotation(JSONSchemaAnnotationId);
/**
 * @category annotations
 * @since 1.0.0
 */
export const getDocumentationAnnotation = /*#__PURE__*/getAnnotation(DocumentationAnnotationId);
/**
 * @category annotations
 * @since 1.0.0
 */
export const getConcurrencyAnnotation = /*#__PURE__*/getAnnotation(ConcurrencyAnnotationId);
/**
 * @category annotations
 * @since 1.0.0
 */
export const getBatchingAnnotation = /*#__PURE__*/getAnnotation(BatchingAnnotationId);
/**
 * @category annotations
 * @since 1.0.0
 */
export const getParseIssueTitleAnnotation = /*#__PURE__*/getAnnotation(ParseIssueTitleAnnotationId);
/** @internal */
export const getSurrogateAnnotation = /*#__PURE__*/getAnnotation(SurrogateAnnotationId);
const JSONIdentifierAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/JSONIdentifier");
/** @internal */
export const getJSONIdentifierAnnotation = /*#__PURE__*/getAnnotation(JSONIdentifierAnnotationId);
/**
 * @category model
 * @since 1.0.0
 */
export class Declaration {
  typeParameters;
  decodeUnknown;
  encodeUnknown;
  annotations;
  /**
   * @since 1.0.0
   */
  _tag = "Declaration";
  constructor(typeParameters, decodeUnknown, encodeUnknown, annotations = {}) {
    this.typeParameters = typeParameters;
    this.decodeUnknown = decodeUnknown;
    this.encodeUnknown = encodeUnknown;
    this.annotations = annotations;
  }
  /**
   * @since 1.0.0
   */
  toString(verbose = false) {
    return Option.getOrElse(getExpected(this, verbose), () => "<declaration schema>");
  }
  /**
   * @since 1.0.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      typeParameters: this.typeParameters.map(ast => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
const createASTGuard = tag => ast => ast._tag === tag;
/**
 * @category guards
 * @since 1.0.0
 */
export const isDeclaration = /*#__PURE__*/createASTGuard("Declaration");
/**
 * @category model
 * @since 1.0.0
 */
export class Literal {
  literal;
  annotations;
  /**
   * @since 1.0.0
   */
  _tag = "Literal";
  constructor(literal, annotations = {}) {
    this.literal = literal;
    this.annotations = annotations;
  }
  /**
   * @since 1.0.0
   */
  toString(verbose = false) {
    return Option.getOrElse(getExpected(this, verbose), () => util_.formatUnknown(this.literal));
  }
  /**
   * @since 1.0.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      literal: Predicate.isBigInt(this.literal) ? String(this.literal) : this.literal,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @category guards
 * @since 1.0.0
 */
export const isLiteral = /*#__PURE__*/createASTGuard("Literal");
const $null = /*#__PURE__*/new Literal(null, {
  [IdentifierAnnotationId]: "null"
});
export {
/**
 * @category constructors
 * @since 1.0.0
 */
$null as null };
/**
 * @category model
 * @since 1.0.0
 */
export class UniqueSymbol {
  symbol;
  annotations;
  /**
   * @since 1.0.0
   */
  _tag = "UniqueSymbol";
  constructor(symbol, annotations = {}) {
    this.symbol = symbol;
    this.annotations = annotations;
  }
  /**
   * @since 1.0.0
   */
  toString(verbose = false) {
    return Option.getOrElse(getExpected(this, verbose), () => util_.formatUnknown(this.symbol));
  }
  /**
   * @since 1.0.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      symbol: String(this.symbol),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @category guards
 * @since 1.0.0
 */
export const isUniqueSymbol = /*#__PURE__*/createASTGuard("UniqueSymbol");
/**
 * @category model
 * @since 1.0.0
 */
export class UndefinedKeyword {
  annotations;
  /**
   * @since 1.0.0
   */
  _tag = "UndefinedKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
   * @since 1.0.0
   */
  toString(verbose = false) {
    return formatKeyword(this, verbose);
  }
  /**
   * @since 1.0.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @category constructors
 * @since 1.0.0
 */
export const undefinedKeyword = /*#__PURE__*/new UndefinedKeyword({
  [TitleAnnotationId]: "undefined"
});
/**
 * @category guards
 * @since 1.0.0
 */
export const isUndefinedKeyword = /*#__PURE__*/createASTGuard("UndefinedKeyword");
/**
 * @category model
 * @since 1.0.0
 */
export class VoidKeyword {
  annotations;
  /**
   * @since 1.0.0
   */
  _tag = "VoidKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
   * @since 1.0.0
   */
  toString(verbose = false) {
    return formatKeyword(this, verbose);
  }
  /**
   * @since 1.0.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @category constructors
 * @since 1.0.0
 */
export const voidKeyword = /*#__PURE__*/new VoidKeyword({
  [TitleAnnotationId]: "void"
});
/**
 * @category guards
 * @since 1.0.0
 */
export const isVoidKeyword = /*#__PURE__*/createASTGuard("VoidKeyword");
/**
 * @category model
 * @since 1.0.0
 */
export class NeverKeyword {
  annotations;
  /**
   * @since 1.0.0
   */
  _tag = "NeverKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
   * @since 1.0.0
   */
  toString(verbose = false) {
    return formatKeyword(this, verbose);
  }
  /**
   * @since 1.0.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @category constructors
 * @since 1.0.0
 */
export const neverKeyword = /*#__PURE__*/new NeverKeyword({
  [TitleAnnotationId]: "never"
});
/**
 * @category guards
 * @since 1.0.0
 */
export const isNeverKeyword = /*#__PURE__*/createASTGuard("NeverKeyword");
/**
 * @category model
 * @since 1.0.0
 */
export class UnknownKeyword {
  annotations;
  /**
   * @since 1.0.0
   */
  _tag = "UnknownKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
   * @since 1.0.0
   */
  toString(verbose = false) {
    return formatKeyword(this, verbose);
  }
  /**
   * @since 1.0.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @category constructors
 * @since 1.0.0
 */
export const unknownKeyword = /*#__PURE__*/new UnknownKeyword({
  [TitleAnnotationId]: "unknown"
});
/**
 * @category guards
 * @since 1.0.0
 */
export const isUnknownKeyword = /*#__PURE__*/createASTGuard("UnknownKeyword");
/**
 * @category model
 * @since 1.0.0
 */
export class AnyKeyword {
  annotations;
  /**
   * @since 1.0.0
   */
  _tag = "AnyKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
   * @since 1.0.0
   */
  toString(verbose = false) {
    return formatKeyword(this, verbose);
  }
  /**
   * @since 1.0.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @category constructors
 * @since 1.0.0
 */
export const anyKeyword = /*#__PURE__*/new AnyKeyword({
  [TitleAnnotationId]: "any"
});
/**
 * @category guards
 * @since 1.0.0
 */
export const isAnyKeyword = /*#__PURE__*/createASTGuard("AnyKeyword");
/**
 * @category model
 * @since 1.0.0
 */
export class StringKeyword {
  annotations;
  /**
   * @since 1.0.0
   */
  _tag = "StringKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
   * @since 1.0.0
   */
  toString(verbose = false) {
    return formatKeyword(this, verbose);
  }
  /**
   * @since 1.0.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @category constructors
 * @since 1.0.0
 */
export const stringKeyword = /*#__PURE__*/new StringKeyword({
  [TitleAnnotationId]: "string",
  [DescriptionAnnotationId]: "a string"
});
/**
 * @category guards
 * @since 1.0.0
 */
export const isStringKeyword = /*#__PURE__*/createASTGuard("StringKeyword");
/**
 * @category model
 * @since 1.0.0
 */
export class NumberKeyword {
  annotations;
  /**
   * @since 1.0.0
   */
  _tag = "NumberKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
   * @since 1.0.0
   */
  toString(verbose = false) {
    return formatKeyword(this, verbose);
  }
  /**
   * @since 1.0.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @category constructors
 * @since 1.0.0
 */
export const numberKeyword = /*#__PURE__*/new NumberKeyword({
  [TitleAnnotationId]: "number",
  [DescriptionAnnotationId]: "a number"
});
/**
 * @category guards
 * @since 1.0.0
 */
export const isNumberKeyword = /*#__PURE__*/createASTGuard("NumberKeyword");
/**
 * @category model
 * @since 1.0.0
 */
export class BooleanKeyword {
  annotations;
  /**
   * @since 1.0.0
   */
  _tag = "BooleanKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
   * @since 1.0.0
   */
  toString(verbose = false) {
    return formatKeyword(this, verbose);
  }
  /**
   * @since 1.0.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @category constructors
 * @since 1.0.0
 */
export const booleanKeyword = /*#__PURE__*/new BooleanKeyword({
  [TitleAnnotationId]: "boolean",
  [DescriptionAnnotationId]: "a boolean"
});
/**
 * @category guards
 * @since 1.0.0
 */
export const isBooleanKeyword = /*#__PURE__*/createASTGuard("BooleanKeyword");
/**
 * @category model
 * @since 1.0.0
 */
export class BigIntKeyword {
  annotations;
  /**
   * @since 1.0.0
   */
  _tag = "BigIntKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
   * @since 1.0.0
   */
  toString(verbose = false) {
    return formatKeyword(this, verbose);
  }
  /**
   * @since 1.0.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @category constructors
 * @since 1.0.0
 */
export const bigIntKeyword = /*#__PURE__*/new BigIntKeyword({
  [TitleAnnotationId]: "bigint",
  [DescriptionAnnotationId]: "a bigint"
});
/**
 * @category guards
 * @since 1.0.0
 */
export const isBigIntKeyword = /*#__PURE__*/createASTGuard("BigIntKeyword");
/**
 * @category model
 * @since 1.0.0
 */
export class SymbolKeyword {
  annotations;
  /**
   * @since 1.0.0
   */
  _tag = "SymbolKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
   * @since 1.0.0
   */
  toString(verbose = false) {
    return formatKeyword(this, verbose);
  }
  /**
   * @since 1.0.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @category constructors
 * @since 1.0.0
 */
export const symbolKeyword = /*#__PURE__*/new SymbolKeyword({
  [TitleAnnotationId]: "symbol",
  [DescriptionAnnotationId]: "a symbol"
});
/**
 * @category guards
 * @since 1.0.0
 */
export const isSymbolKeyword = /*#__PURE__*/createASTGuard("SymbolKeyword");
/**
 * @category model
 * @since 1.0.0
 */
export class ObjectKeyword {
  annotations;
  /**
   * @since 1.0.0
   */
  _tag = "ObjectKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
   * @since 1.0.0
   */
  toString(verbose = false) {
    return formatKeyword(this, verbose);
  }
  /**
   * @since 1.0.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @category constructors
 * @since 1.0.0
 */
export const objectKeyword = /*#__PURE__*/new ObjectKeyword({
  [IdentifierAnnotationId]: "object",
  [TitleAnnotationId]: "object",
  [DescriptionAnnotationId]: "an object in the TypeScript meaning, i.e. the `object` type"
});
/**
 * @category guards
 * @since 1.0.0
 */
export const isObjectKeyword = /*#__PURE__*/createASTGuard("ObjectKeyword");
/**
 * @category model
 * @since 1.0.0
 */
export class Enums {
  enums;
  annotations;
  /**
   * @since 1.0.0
   */
  _tag = "Enums";
  constructor(enums, annotations = {}) {
    this.enums = enums;
    this.annotations = annotations;
  }
  /**
   * @since 1.0.0
   */
  toString(verbose = false) {
    return Option.getOrElse(getExpected(this, verbose), () => `<enum ${this.enums.length} value(s): ${this.enums.map((_, value) => JSON.stringify(value)).join(" | ")}>`);
  }
  /**
   * @since 1.0.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      enums: this.enums,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @category guards
 * @since 1.0.0
 */
export const isEnums = /*#__PURE__*/createASTGuard("Enums");
/**
 * @category model
 * @since 1.0.0
 */
export class TemplateLiteralSpan {
  type;
  literal;
  constructor(type, literal) {
    this.type = type;
    this.literal = literal;
  }
  /**
   * @since 1.0.0
   */
  toString() {
    switch (this.type._tag) {
      case "StringKeyword":
        return "${string}";
      case "NumberKeyword":
        return "${number}";
    }
  }
  /**
   * @since 1.0.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      literal: this.literal
    };
  }
}
/**
 * @category model
 * @since 1.0.0
 */
export class TemplateLiteral {
  head;
  spans;
  annotations;
  static make = (head, spans, annotations = {}) => Arr.isNonEmptyReadonlyArray(spans) ? new TemplateLiteral(head, spans, annotations) : new Literal(head);
  /**
   * @since 1.0.0
   */
  _tag = "TemplateLiteral";
  constructor(head, spans, annotations = {}) {
    this.head = head;
    this.spans = spans;
    this.annotations = annotations;
  }
  /**
   * @since 1.0.0
   */
  toString(verbose = false) {
    return Option.getOrElse(getExpected(this, verbose), () => formatTemplateLiteral(this));
  }
  /**
   * @since 1.0.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      head: this.head,
      spans: this.spans.map(span => span.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
const formatTemplateLiteral = ast => "`" + ast.head + ast.spans.map(span => String(span) + span.literal).join("") + "`";
/**
 * @category guards
 * @since 1.0.0
 */
export const isTemplateLiteral = /*#__PURE__*/createASTGuard("TemplateLiteral");
/**
 * @category model
 * @since 1.0.0
 */
export class Element {
  type;
  isOptional;
  constructor(type, isOptional) {
    this.type = type;
    this.isOptional = isOptional;
  }
  /**
   * @since 1.0.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      isOptional: this.isOptional
    };
  }
  /**
   * @since 1.0.0
   */
  toString() {
    return String(this.type) + (this.isOptional ? "?" : "");
  }
}
/**
 * @category model
 * @since 1.0.0
 */
export class TupleType {
  elements;
  rest;
  isReadonly;
  annotations;
  /**
   * @since 1.0.0
   */
  _tag = "TupleType";
  constructor(elements, rest, isReadonly, annotations = {}) {
    this.elements = elements;
    this.rest = rest;
    this.isReadonly = isReadonly;
    this.annotations = annotations;
    let hasOptionalElement = false;
    let hasIllegalRequiredElement = false;
    for (const e of elements) {
      if (e.isOptional) {
        hasOptionalElement = true;
      } else if (hasOptionalElement) {
        hasIllegalRequiredElement = true;
        break;
      }
    }
    if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) {
      throw new Error(errors_.getRequiredElementFollowinAnOptionalElementErrorMessage);
    }
  }
  /**
   * @since 1.0.0
   */
  toString(verbose = false) {
    return Option.getOrElse(getExpected(this, verbose), () => formatTuple(this));
  }
  /**
   * @since 1.0.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      elements: this.elements.map(e => e.toJSON()),
      rest: this.rest.map(ast => ast.toJSON()),
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
const formatTuple = ast => {
  const formattedElements = ast.elements.map(String).join(", ");
  return Arr.matchLeft(ast.rest, {
    onEmpty: () => `readonly [${formattedElements}]`,
    onNonEmpty: (head, tail) => {
      const formattedHead = String(head);
      const wrappedHead = formattedHead.includes(" | ") ? `(${formattedHead})` : formattedHead;
      if (tail.length > 0) {
        const formattedTail = tail.map(String).join(", ");
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
        } else {
          return `readonly [...${wrappedHead}[], ${formattedTail}]`;
        }
      } else {
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
        } else {
          return `ReadonlyArray<${formattedHead}>`;
        }
      }
    }
  });
};
/**
 * @category guards
 * @since 1.0.0
 */
export const isTupleType = /*#__PURE__*/createASTGuard("TupleType");
/**
 * @category model
 * @since 1.0.0
 */
export class PropertySignature {
  name;
  type;
  isOptional;
  isReadonly;
  annotations;
  constructor(name, type, isOptional, isReadonly, annotations = {}) {
    this.name = name;
    this.type = type;
    this.isOptional = isOptional;
    this.isReadonly = isReadonly;
    this.annotations = annotations;
  }
  /**
   * @since 1.0.0
   */
  toJSON() {
    return {
      name: String(this.name),
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @since 1.0.0
 */
export const isParameter = ast => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return true;
    case "Refinement":
      return isParameter(ast.from);
  }
  return false;
};
/**
 * @category model
 * @since 1.0.0
 */
export class IndexSignature {
  type;
  isReadonly;
  /**
   * @since 1.0.0
   */
  parameter;
  constructor(parameter, type, isReadonly) {
    this.type = type;
    this.isReadonly = isReadonly;
    if (isParameter(parameter)) {
      this.parameter = parameter;
    } else {
      throw new Error(errors_.getIndexSignatureParameterErrorMessage);
    }
  }
  /**
   * @since 1.0.0
   */
  toJSON() {
    return {
      parameter: this.parameter.toJSON(),
      type: this.type.toJSON(),
      isReadonly: this.isReadonly
    };
  }
}
/**
 * @category model
 * @since 1.0.0
 */
export class TypeLiteral {
  annotations;
  /**
   * @since 1.0.0
   */
  _tag = "TypeLiteral";
  /**
   * @since 1.0.0
   */
  propertySignatures;
  /**
   * @since 1.0.0
   */
  indexSignatures;
  constructor(propertySignatures, indexSignatures, annotations = {}) {
    this.annotations = annotations;
    // check for duplicate property signatures
    const keys = {};
    for (let i = 0; i < propertySignatures.length; i++) {
      const name = propertySignatures[i].name;
      if (Object.prototype.hasOwnProperty.call(keys, name)) {
        throw new Error(errors_.getDuplicatePropertySignatureErrorMessage(name));
      }
      keys[name] = null;
    }
    // check for duplicate index signatures
    const parameters = {
      string: false,
      symbol: false
    };
    for (let i = 0; i < indexSignatures.length; i++) {
      const parameter = getParameterBase(indexSignatures[i].parameter);
      if (isStringKeyword(parameter)) {
        if (parameters.string) {
          throw new Error(errors_.getDuplicateIndexSignatureErrorMessage("string"));
        }
        parameters.string = true;
      } else if (isSymbolKeyword(parameter)) {
        if (parameters.symbol) {
          throw new Error(errors_.getDuplicateIndexSignatureErrorMessage("symbol"));
        }
        parameters.symbol = true;
      }
    }
    this.propertySignatures = sortPropertySignatures(propertySignatures);
    this.indexSignatures = sortIndexSignatures(indexSignatures);
  }
  /**
   * @since 1.0.0
   */
  toString(verbose = false) {
    return Option.getOrElse(getExpected(this, verbose), () => formatTypeLiteral(this));
  }
  /**
   * @since 1.0.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      propertySignatures: this.propertySignatures.map(ps => ps.toJSON()),
      indexSignatures: this.indexSignatures.map(ps => ps.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
const formatTypeLiteral = ast => {
  const formattedPropertySignatures = ast.propertySignatures.map(ps => String(ps.name) + (ps.isOptional ? "?" : "") + ": " + ps.type).join("; ");
  if (ast.indexSignatures.length > 0) {
    const formattedIndexSignatures = ast.indexSignatures.map(is => `[x: ${getParameterBase(is.parameter)}]: ${is.type}`).join("; ");
    if (ast.propertySignatures.length > 0) {
      return `{ ${formattedPropertySignatures}; ${formattedIndexSignatures} }`;
    } else {
      return `{ ${formattedIndexSignatures} }`;
    }
  } else {
    if (ast.propertySignatures.length > 0) {
      return `{ ${formattedPropertySignatures} }`;
    } else {
      return "{}";
    }
  }
};
/**
 * @category guards
 * @since 1.0.0
 */
export const isTypeLiteral = /*#__PURE__*/createASTGuard("TypeLiteral");
const removeNevers = candidates => candidates.filter(ast => !(ast === neverKeyword));
const sortCandidates = /*#__PURE__*/Arr.sort( /*#__PURE__*/Order.mapInput(Number.Order, ast => {
  switch (ast._tag) {
    case "AnyKeyword":
      return 0;
    case "UnknownKeyword":
      return 1;
    case "ObjectKeyword":
      return 2;
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
      return 3;
  }
  return 4;
}));
const literalMap = {
  string: "StringKeyword",
  number: "NumberKeyword",
  boolean: "BooleanKeyword",
  bigint: "BigIntKeyword"
};
/** @internal */
export const flatten = candidates => Arr.flatMap(candidates, ast => isUnion(ast) ? flatten(ast.types) : [ast]);
/** @internal */
export const unify = candidates => {
  const cs = sortCandidates(candidates);
  const out = [];
  const uniques = {};
  const literals = [];
  for (const ast of cs) {
    switch (ast._tag) {
      case "NeverKeyword":
        break;
      case "AnyKeyword":
        return [anyKeyword];
      case "UnknownKeyword":
        return [unknownKeyword];
      // uniques
      case "ObjectKeyword":
      case "UndefinedKeyword":
      case "VoidKeyword":
      case "StringKeyword":
      case "NumberKeyword":
      case "BooleanKeyword":
      case "BigIntKeyword":
      case "SymbolKeyword":
        {
          if (!uniques[ast._tag]) {
            uniques[ast._tag] = ast;
            out.push(ast);
          }
          break;
        }
      case "Literal":
        {
          const type = typeof ast.literal;
          switch (type) {
            case "string":
            case "number":
            case "bigint":
            case "boolean":
              {
                const _tag = literalMap[type];
                if (!uniques[_tag] && !literals.includes(ast.literal)) {
                  literals.push(ast.literal);
                  out.push(ast);
                }
                break;
              }
            // null
            case "object":
              {
                if (!literals.includes(ast.literal)) {
                  literals.push(ast.literal);
                  out.push(ast);
                }
                break;
              }
          }
          break;
        }
      case "UniqueSymbol":
        {
          if (!uniques["SymbolKeyword"] && !literals.includes(ast.symbol)) {
            literals.push(ast.symbol);
            out.push(ast);
          }
          break;
        }
      case "TupleType":
        {
          if (!uniques["ObjectKeyword"]) {
            out.push(ast);
          }
          break;
        }
      case "TypeLiteral":
        {
          if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
            if (!uniques["{}"]) {
              uniques["{}"] = ast;
              out.push(ast);
            }
          } else if (!uniques["ObjectKeyword"]) {
            out.push(ast);
          }
          break;
        }
      default:
        out.push(ast);
    }
  }
  return out;
};
/**
 * @category model
 * @since 1.0.0
 */
export class Union {
  types;
  annotations;
  static make = (candidates, annotations) => {
    const types = [];
    const memo = new Set();
    for (let i = 0; i < candidates.length; i++) {
      const ast = candidates[i];
      if (ast === neverKeyword || memo.has(ast)) {
        continue;
      }
      memo.add(ast);
      types.push(ast);
    }
    return Union.union(types, annotations);
  };
  /** @internal */
  static members = (candidates, annotations) => {
    return Union.union(removeNevers(candidates), annotations);
  };
  /** @internal */
  static unify = (candidates, annotations) => {
    return Union.union(unify(flatten(candidates)), annotations);
  };
  /** @internal */
  static union = (types, annotations) => {
    return isMembers(types) ? new Union(types, annotations) : types.length === 1 ? types[0] : neverKeyword;
  };
  /**
   * @since 1.0.0
   */
  _tag = "Union";
  constructor(types, annotations = {}) {
    this.types = types;
    this.annotations = annotations;
  }
  /**
   * @since 1.0.0
   */
  toString(verbose = false) {
    return Option.getOrElse(getExpected(this, verbose), () => this.types.map(String).join(" | "));
  }
  /**
   * @since 1.0.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      types: this.types.map(ast => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/** @internal */
export const mapMembers = (members, f) => members.map(f);
/** @internal */
export const isMembers = as => as.length > 1;
/**
 * @category guards
 * @since 1.0.0
 */
export const isUnion = /*#__PURE__*/createASTGuard("Union");
const toJSONMemoMap = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for("@effect/schema/AST/toJSONMemoMap"), () => new WeakMap());
/**
 * @category model
 * @since 1.0.0
 */
export class Suspend {
  f;
  annotations;
  /**
   * @since 1.0.0
   */
  _tag = "Suspend";
  constructor(f, annotations = {}) {
    this.f = f;
    this.annotations = annotations;
    this.f = util_.memoizeThunk(f);
  }
  /**
   * @since 1.0.0
   */
  toString(verbose = false) {
    return getExpected(this, verbose).pipe(Option.orElse(() => Option.flatMap(Option.liftThrowable(this.f)(), ast => getExpected(ast, verbose))), Option.getOrElse(() => "<suspended schema>"));
  }
  /**
   * @since 1.0.0
   */
  toJSON() {
    const ast = this.f();
    let out = toJSONMemoMap.get(ast);
    if (out) {
      return out;
    }
    toJSONMemoMap.set(ast, {
      _tag: this._tag
    });
    out = {
      _tag: this._tag,
      ast: ast.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
    toJSONMemoMap.set(ast, out);
    return out;
  }
}
/**
 * @category guards
 * @since 1.0.0
 */
export const isSuspend = /*#__PURE__*/createASTGuard("Suspend");
/**
 * @category model
 * @since 1.0.0
 */
export class Refinement {
  from;
  filter;
  annotations;
  /**
   * @since 1.0.0
   */
  _tag = "Refinement";
  constructor(from, filter, annotations = {}) {
    this.from = from;
    this.filter = filter;
    this.annotations = annotations;
  }
  /**
   * @since 1.0.0
   */
  toString(verbose = false) {
    return Option.getOrElse(getExpected(this, verbose), () => "<refinement schema>");
  }
  /**
   * @since 1.0.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @category guards
 * @since 1.0.0
 */
export const isRefinement = /*#__PURE__*/createASTGuard("Refinement");
/**
 * @since 1.0.0
 */
export const defaultParseOption = {};
/**
 * @category model
 * @since 1.0.0
 */
export class Transformation {
  from;
  to;
  transformation;
  annotations;
  /**
   * @since 1.0.0
   */
  _tag = "Transformation";
  constructor(from, to, transformation, annotations = {}) {
    this.from = from;
    this.to = to;
    this.transformation = transformation;
    this.annotations = annotations;
  }
  /**
   * @since 1.0.0
   */
  toString(verbose = false) {
    return Option.getOrElse(getExpected(this, verbose), () => `(${String(this.from)} <-> ${String(this.to)})`);
  }
  /**
   * @since 1.0.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      to: this.to.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @category guards
 * @since 1.0.0
 */
export const isTransformation = /*#__PURE__*/createASTGuard("Transformation");
/**
 * @category model
 * @since 1.0.0
 */
export class FinalTransformation {
  decode;
  encode;
  /**
   * @since 1.0.0
   */
  _tag = "FinalTransformation";
  constructor(decode, encode) {
    this.decode = decode;
    this.encode = encode;
  }
}
const createTransformationGuard = tag => ast => ast._tag === tag;
/**
 * @category guards
 * @since 1.0.0
 */
export const isFinalTransformation = /*#__PURE__*/createTransformationGuard("FinalTransformation");
/**
 * @category model
 * @since 1.0.0
 */
export class ComposeTransformation {
  /**
   * @since 1.0.0
   */
  _tag = "ComposeTransformation";
}
/**
 * @category constructors
 * @since 1.0.0
 */
export const composeTransformation = /*#__PURE__*/new ComposeTransformation();
/**
 * @category guards
 * @since 1.0.0
 */
export const isComposeTransformation = /*#__PURE__*/createTransformationGuard("ComposeTransformation");
/**
 * Represents a `PropertySignature -> PropertySignature` transformation
 *
 * The semantic of `decode` is:
 * - `none()` represents the absence of the key/value pair
 * - `some(value)` represents the presence of the key/value pair
 *
 * The semantic of `encode` is:
 * - `none()` you don't want to output the key/value pair
 * - `some(value)` you want to output the key/value pair
 *
 * @category model
 * @since 1.0.0
 */
export class PropertySignatureTransformation {
  from;
  to;
  decode;
  encode;
  constructor(from, to, decode, encode) {
    this.from = from;
    this.to = to;
    this.decode = decode;
    this.encode = encode;
  }
}
const isRenamingPropertySignatureTransformation = t => t.decode === identity && t.encode === identity;
/**
 * @category model
 * @since 1.0.0
 */
export class TypeLiteralTransformation {
  propertySignatureTransformations;
  /**
   * @since 1.0.0
   */
  _tag = "TypeLiteralTransformation";
  constructor(propertySignatureTransformations) {
    this.propertySignatureTransformations = propertySignatureTransformations;
    // check for duplicate property signature transformations
    const fromKeys = {};
    const toKeys = {};
    for (const pst of propertySignatureTransformations) {
      const from = pst.from;
      if (fromKeys[from]) {
        throw new Error(errors_.getDuplicatePropertySignatureTransformationErrorMessage(from));
      }
      fromKeys[from] = true;
      const to = pst.to;
      if (toKeys[to]) {
        throw new Error(errors_.getDuplicatePropertySignatureTransformationErrorMessage(to));
      }
      toKeys[to] = true;
    }
  }
}
/**
 * @category guards
 * @since 1.0.0
 */
export const isTypeLiteralTransformation = /*#__PURE__*/createTransformationGuard("TypeLiteralTransformation");
// -------------------------------------------------------------------------------------
// API
// -------------------------------------------------------------------------------------
/**
 * Adds a group of annotations, potentially overwriting existing annotations.
 *
 * @since 1.0.0
 */
export const annotations = (ast, annotations) => {
  const d = Object.getOwnPropertyDescriptors(ast);
  d.annotations.value = {
    ...ast.annotations,
    ...annotations
  };
  return Object.create(Object.getPrototypeOf(ast), d);
};
/**
 * Equivalent at runtime to the TypeScript type-level `keyof` operator.
 *
 * @since 1.0.0
 */
export const keyof = ast => Union.unify(_keyof(ast));
const STRING_KEYWORD_PATTERN = ".*";
const NUMBER_KEYWORD_PATTERN = "[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?";
/**
 * @since 1.0.0
 */
export const getTemplateLiteralRegExp = ast => {
  let pattern = `^${regexp.escape(ast.head)}`;
  for (const span of ast.spans) {
    if (isStringKeyword(span.type)) {
      pattern += STRING_KEYWORD_PATTERN;
    } else if (isNumberKeyword(span.type)) {
      pattern += NUMBER_KEYWORD_PATTERN;
    }
    pattern += regexp.escape(span.literal);
  }
  pattern += "$";
  return new RegExp(pattern);
};
/**
 * @since 1.0.0
 */
export const getPropertySignatures = ast => {
  switch (ast._tag) {
    case "Declaration":
      {
        const annotation = getSurrogateAnnotation(ast);
        if (Option.isSome(annotation)) {
          return getPropertySignatures(annotation.value);
        }
        break;
      }
    case "TypeLiteral":
      return ast.propertySignatures.slice();
    case "Suspend":
      return getPropertySignatures(ast.f());
  }
  return getPropertyKeys(ast).map(name => getPropertyKeyIndexedAccess(ast, name));
};
/** @internal */
export const getNumberIndexedAccess = ast => {
  switch (ast._tag) {
    case "TupleType":
      {
        let hasOptional = false;
        let out = [];
        for (const e of ast.elements) {
          if (e.isOptional) {
            hasOptional = true;
          }
          out.push(e.type);
        }
        if (hasOptional) {
          out.push(undefinedKeyword);
        }
        out = out.concat(ast.rest);
        return Union.make(out);
      }
    case "Refinement":
      return getNumberIndexedAccess(ast.from);
    case "Union":
      return Union.make(ast.types.map(getNumberIndexedAccess));
    case "Suspend":
      return getNumberIndexedAccess(ast.f());
  }
  throw new Error(errors_.getAPIErrorMessage("NumberIndexedAccess", `unsupported schema (${ast})`));
};
/** @internal */
export const getPropertyKeyIndexedAccess = (ast, name) => {
  switch (ast._tag) {
    case "Declaration":
      {
        const annotation = getSurrogateAnnotation(ast);
        if (Option.isSome(annotation)) {
          return getPropertyKeyIndexedAccess(annotation.value, name);
        }
        break;
      }
    case "TypeLiteral":
      {
        const ops = Arr.findFirst(ast.propertySignatures, ps => ps.name === name);
        if (Option.isSome(ops)) {
          return ops.value;
        } else {
          if (Predicate.isString(name)) {
            for (const is of ast.indexSignatures) {
              const parameterBase = getParameterBase(is.parameter);
              switch (parameterBase._tag) {
                case "TemplateLiteral":
                  {
                    const regex = getTemplateLiteralRegExp(parameterBase);
                    if (regex.test(name)) {
                      return new PropertySignature(name, is.type, false, false);
                    }
                    break;
                  }
                case "StringKeyword":
                  return new PropertySignature(name, is.type, false, false);
              }
            }
          } else if (Predicate.isSymbol(name)) {
            for (const is of ast.indexSignatures) {
              const parameterBase = getParameterBase(is.parameter);
              if (isSymbolKeyword(parameterBase)) {
                return new PropertySignature(name, is.type, false, false);
              }
            }
          }
        }
        break;
      }
    case "Union":
      return new PropertySignature(name, Union.make(ast.types.map(ast => getPropertyKeyIndexedAccess(ast, name).type)), false, true);
    case "Suspend":
      return getPropertyKeyIndexedAccess(ast.f(), name);
  }
  return new PropertySignature(name, neverKeyword, false, true);
};
const getPropertyKeys = ast => {
  switch (ast._tag) {
    case "Declaration":
      {
        const annotation = getSurrogateAnnotation(ast);
        if (Option.isSome(annotation)) {
          return getPropertyKeys(annotation.value);
        }
        break;
      }
    case "TypeLiteral":
      return ast.propertySignatures.map(ps => ps.name);
    case "Suspend":
      return getPropertyKeys(ast.f());
    case "Union":
      return ast.types.slice(1).reduce((out, ast) => Arr.intersection(out, getPropertyKeys(ast)), getPropertyKeys(ast.types[0]));
    case "Transformation":
      return getPropertyKeys(ast.to);
  }
  return [];
};
/** @internal */
export const record = (key, value) => {
  const propertySignatures = [];
  const indexSignatures = [];
  const go = key => {
    switch (key._tag) {
      case "NeverKeyword":
        break;
      case "StringKeyword":
      case "SymbolKeyword":
      case "TemplateLiteral":
      case "Refinement":
        indexSignatures.push(new IndexSignature(key, value, true));
        break;
      case "Literal":
        if (Predicate.isString(key.literal) || Predicate.isNumber(key.literal)) {
          propertySignatures.push(new PropertySignature(key.literal, value, false, true));
        } else {
          throw new Error(errors_.getAPIErrorMessage("Record", `unsupported literal (${util_.formatUnknown(key.literal)})`));
        }
        break;
      case "UniqueSymbol":
        propertySignatures.push(new PropertySignature(key.symbol, value, false, true));
        break;
      case "Union":
        key.types.forEach(go);
        break;
      default:
        throw new Error(errors_.getAPIErrorMessage("Record", `unsupported key schema (${key})`));
    }
  };
  go(key);
  return {
    propertySignatures,
    indexSignatures
  };
};
/**
 * Equivalent at runtime to the built-in TypeScript utility type `Pick`.
 *
 * @since 1.0.0
 */
export const pick = (ast, keys) => {
  if (isTransformation(ast)) {
    switch (ast.transformation._tag) {
      case "ComposeTransformation":
        return new Transformation(pick(ast.from, keys), pick(ast.to, keys), composeTransformation);
      case "TypeLiteralTransformation":
        {
          const ts = [];
          const fromKeys = [];
          for (const k of keys) {
            const t = ast.transformation.propertySignatureTransformations.find(t => t.to === k);
            if (t) {
              ts.push(t);
              fromKeys.push(t.from);
            } else {
              fromKeys.push(k);
            }
          }
          return new Transformation(pick(ast.from, fromKeys), pick(ast.to, keys), Arr.isNonEmptyReadonlyArray(ts) ? new TypeLiteralTransformation(ts) : composeTransformation);
        }
      case "FinalTransformation":
        {
          const annotation = getSurrogateAnnotation(ast);
          if (Option.isSome(annotation)) {
            return pick(annotation.value, keys);
          }
          throw new Error(errors_.getAPIErrorMessage("Pick", "cannot handle this kind of transformation"));
        }
    }
  }
  return new TypeLiteral(keys.map(key => getPropertyKeyIndexedAccess(ast, key)), []);
};
/**
 * Equivalent at runtime to the built-in TypeScript utility type `Omit`.
 *
 * @since 1.0.0
 */
export const omit = (ast, keys) => pick(ast, getPropertyKeys(ast).filter(name => !keys.includes(name)));
/** @internal */
export const orUndefined = ast => Union.make([ast, undefinedKeyword]);
/**
 * Equivalent at runtime to the built-in TypeScript utility type `Partial`.
 *
 * @since 1.0.0
 */
export const partial = (ast, options) => {
  const exact = options?.exact === true;
  switch (ast._tag) {
    case "TupleType":
      return new TupleType(ast.elements.map(e => new Element(exact ? e.type : orUndefined(e.type), true)), Arr.match(ast.rest, {
        onEmpty: () => ast.rest,
        onNonEmpty: rest => [Union.make([...rest, undefinedKeyword])]
      }), ast.isReadonly);
    case "TypeLiteral":
      return new TypeLiteral(ast.propertySignatures.map(ps => new PropertySignature(ps.name, exact ? ps.type : orUndefined(ps.type), true, ps.isReadonly, ps.annotations)), ast.indexSignatures.map(is => new IndexSignature(is.parameter, orUndefined(is.type), is.isReadonly)));
    case "Union":
      return Union.make(ast.types.map(member => partial(member, options)));
    case "Suspend":
      return new Suspend(() => partial(ast.f(), options));
    case "Declaration":
      throw new Error(errors_.getAPIErrorMessage("partial", "cannot handle declarations"));
    case "Refinement":
      throw new Error(errors_.getAPIErrorMessage("partial", "cannot handle refinements"));
    case "Transformation":
      {
        if (isTypeLiteralTransformation(ast.transformation) && ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation)) {
          return new Transformation(partial(ast.from, options), partial(ast.to, options), ast.transformation);
        }
        throw new Error(errors_.getAPIErrorMessage("partial", "cannot handle transformations"));
      }
  }
  return ast;
};
/**
 * Equivalent at runtime to the built-in TypeScript utility type `Required`.
 *
 * @since 1.0.0
 */
export const required = ast => {
  switch (ast._tag) {
    case "TupleType":
      return new TupleType(ast.elements.map(e => new Element(e.type, false)), ast.rest, ast.isReadonly);
    case "TypeLiteral":
      return new TypeLiteral(ast.propertySignatures.map(f => new PropertySignature(f.name, f.type, false, f.isReadonly, f.annotations)), ast.indexSignatures);
    case "Union":
      return Union.make(ast.types.map(member => required(member)));
    case "Suspend":
      return new Suspend(() => required(ast.f()));
    case "Declaration":
      throw new Error(errors_.getAPIErrorMessage("required", "cannot handle declarations"));
    case "Refinement":
      throw new Error(errors_.getAPIErrorMessage("required", "cannot handle refinements"));
    case "Transformation":
      {
        if (isTypeLiteralTransformation(ast.transformation) && ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation)) {
          return new Transformation(required(ast.from), required(ast.to), ast.transformation);
        }
        throw new Error(errors_.getAPIErrorMessage("required", "cannot handle transformations"));
      }
  }
  return ast;
};
/**
 * Creates a new AST with shallow mutability applied to its properties.
 *
 * @param ast - The original AST to make properties mutable (shallowly).
 *
 * @since 1.0.0
 */
export const mutable = ast => {
  switch (ast._tag) {
    case "TupleType":
      return ast.isReadonly === false ? ast : new TupleType(ast.elements, ast.rest, false, ast.annotations);
    case "TypeLiteral":
      {
        const propertySignatures = changeMap(ast.propertySignatures, ps => ps.isReadonly === false ? ps : new PropertySignature(ps.name, ps.type, ps.isOptional, false, ps.annotations));
        const indexSignatures = changeMap(ast.indexSignatures, is => is.isReadonly === false ? is : new IndexSignature(is.parameter, is.type, false));
        return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
      }
    case "Union":
      {
        const types = changeMap(ast.types, mutable);
        return types === ast.types ? ast : Union.make(types, ast.annotations);
      }
    case "Suspend":
      return new Suspend(() => mutable(ast.f()), ast.annotations);
    case "Refinement":
      {
        const from = mutable(ast.from);
        return from === ast.from ? ast : new Refinement(from, ast.filter, ast.annotations);
      }
    case "Transformation":
      {
        const from = mutable(ast.from);
        const to = mutable(ast.to);
        return from === ast.from && to === ast.to ? ast : new Transformation(from, to, ast.transformation, ast.annotations);
      }
  }
  return ast;
};
/**
 * @since 1.0.0
 */
export const getCompiler = match => {
  const compile = ast => match[ast._tag](ast, compile);
  return compile;
};
/** @internal */
export const getToPropertySignatures = ps => ps.map(p => new PropertySignature(p.name, typeAST(p.type), p.isOptional, p.isReadonly, p.annotations));
/** @internal */
export const getToIndexSignatures = ps => ps.map(is => new IndexSignature(is.parameter, typeAST(is.type), is.isReadonly));
/**
 * @since 1.0.0
 */
export const typeAST = ast => {
  switch (ast._tag) {
    case "Declaration":
      {
        const typeParameters = changeMap(ast.typeParameters, typeAST);
        return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
      }
    case "TupleType":
      {
        const elements = changeMap(ast.elements, e => {
          const type = typeAST(e.type);
          return type === e.type ? e : new Element(type, e.isOptional);
        });
        const rest = changeMap(ast.rest, typeAST);
        return elements === ast.elements && rest === ast.rest ? ast : new TupleType(elements, rest, ast.isReadonly, ast.annotations);
      }
    case "TypeLiteral":
      {
        const propertySignatures = changeMap(ast.propertySignatures, p => {
          const type = typeAST(p.type);
          return type === p.type ? p : new PropertySignature(p.name, type, p.isOptional, p.isReadonly);
        });
        const indexSignatures = changeMap(ast.indexSignatures, is => {
          const type = typeAST(is.type);
          return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly);
        });
        return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
      }
    case "Union":
      {
        const types = changeMap(ast.types, typeAST);
        return types === ast.types ? ast : Union.make(types, ast.annotations);
      }
    case "Suspend":
      return new Suspend(() => typeAST(ast.f()), ast.annotations);
    case "Refinement":
      {
        const from = typeAST(ast.from);
        return from === ast.from ? ast : new Refinement(from, ast.filter, ast.annotations);
      }
    case "Transformation":
      return typeAST(ast.to);
  }
  return ast;
};
/** @internal */
export const getJSONIdentifier = annotated => Option.orElse(getJSONIdentifierAnnotation(annotated), () => getIdentifierAnnotation(annotated));
const createJSONIdentifierAnnotation = annotated => Option.match(getJSONIdentifier(annotated), {
  onNone: () => undefined,
  onSome: identifier => ({
    [JSONIdentifierAnnotationId]: identifier
  })
});
function changeMap(as, f) {
  let changed = false;
  const out = Arr.allocate(as.length);
  for (let i = 0; i < as.length; i++) {
    const a = as[i];
    const fa = f(a);
    if (fa !== a) {
      changed = true;
    }
    out[i] = fa;
  }
  return changed ? out : as;
}
/**
 * @since 1.0.0
 */
export const encodedAST = ast => {
  switch (ast._tag) {
    case "Declaration":
      {
        const typeParameters = changeMap(ast.typeParameters, encodedAST);
        return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
      }
    case "TupleType":
      {
        const elements = changeMap(ast.elements, e => {
          const type = encodedAST(e.type);
          return type === e.type ? e : new Element(type, e.isOptional);
        });
        const rest = changeMap(ast.rest, encodedAST);
        return elements === ast.elements && rest === ast.rest ? ast : new TupleType(elements, rest, ast.isReadonly, createJSONIdentifierAnnotation(ast));
      }
    case "TypeLiteral":
      {
        const propertySignatures = changeMap(ast.propertySignatures, ps => {
          const type = encodedAST(ps.type);
          return type === ps.type ? ps : new PropertySignature(ps.name, type, ps.isOptional, ps.isReadonly);
        });
        const indexSignatures = changeMap(ast.indexSignatures, is => {
          const type = encodedAST(is.type);
          return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly);
        });
        return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, createJSONIdentifierAnnotation(ast));
      }
    case "Union":
      {
        const types = changeMap(ast.types, encodedAST);
        return types === ast.types ? ast : Union.make(types, createJSONIdentifierAnnotation(ast));
      }
    case "Suspend":
      return new Suspend(() => encodedAST(ast.f()), createJSONIdentifierAnnotation(ast));
    case "Refinement":
    case "Transformation":
      return encodedAST(ast.from);
  }
  return ast;
};
const toJSONAnnotations = annotations => {
  const out = {};
  for (const k of Object.getOwnPropertySymbols(annotations)) {
    out[String(k)] = annotations[k];
  }
  return out;
};
/**
 * @since 1.0.0
 */
export const hash = ast => Hash.string(JSON.stringify(ast, null, 2));
/** @internal */
export const getCardinality = ast => {
  switch (ast._tag) {
    case "NeverKeyword":
      return 0;
    case "Literal":
    case "UndefinedKeyword":
    case "VoidKeyword":
    case "UniqueSymbol":
      return 1;
    case "BooleanKeyword":
      return 2;
    case "StringKeyword":
    case "NumberKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
      return 3;
    case "ObjectKeyword":
      return 5;
    case "UnknownKeyword":
    case "AnyKeyword":
      return 6;
    default:
      return 4;
  }
};
const sortPropertySignatures = /*#__PURE__*/Arr.sort( /*#__PURE__*/Order.mapInput(Number.Order, ps => getCardinality(ps.type)));
const sortIndexSignatures = /*#__PURE__*/Arr.sort( /*#__PURE__*/Order.mapInput(Number.Order, is => {
  switch (getParameterBase(is.parameter)._tag) {
    case "StringKeyword":
      return 2;
    case "SymbolKeyword":
      return 3;
    case "TemplateLiteral":
      return 1;
  }
}));
const WeightOrder = /*#__PURE__*/Order.tuple(Number.Order, Number.Order, Number.Order);
const maxWeight = /*#__PURE__*/Order.max(WeightOrder);
const emptyWeight = [0, 0, 0];
const maxWeightAll = weights => weights.reduce(maxWeight, emptyWeight);
/** @internal */
export const getWeight = ast => {
  switch (ast._tag) {
    case "TupleType":
      {
        return [2, ast.elements.length, ast.rest.length];
      }
    case "TypeLiteral":
      {
        const y = ast.propertySignatures.length;
        const z = ast.indexSignatures.length;
        return y + z === 0 ? [-4, 0, 0] : [4, y, z];
      }
    case "Declaration":
      {
        const annotation = getSurrogateAnnotation(ast);
        if (Option.isSome(annotation)) {
          const [_, y, z] = getWeight(annotation.value);
          return [6, y, z];
        }
        return [6, 0, 0];
      }
    case "Suspend":
      return [8, 0, 0];
    case "Union":
      return maxWeightAll(ast.types.map(getWeight));
    case "Refinement":
      {
        const [x, y, z] = getWeight(ast.from);
        return [x + 1, y, z];
      }
    case "Transformation":
      return getWeight(ast.from);
    case "ObjectKeyword":
      return [-2, 0, 0];
    case "UnknownKeyword":
    case "AnyKeyword":
      return [-4, 0, 0];
    default:
      return emptyWeight;
  }
};
/** @internal */
export const getParameterBase = ast => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return ast;
    case "Refinement":
      return getParameterBase(ast.from);
  }
};
const equalsTemplateLiteralSpan = /*#__PURE__*/Arr.getEquivalence((self, that) => self.type._tag === that.type._tag && self.literal === that.literal);
const equalsEnums = /*#__PURE__*/Arr.getEquivalence((self, that) => that[0] === self[0] && that[1] === self[1]);
const equals = (self, that) => {
  switch (self._tag) {
    case "Literal":
      return isLiteral(that) && that.literal === self.literal;
    case "UniqueSymbol":
      return isUniqueSymbol(that) && that.symbol === self.symbol;
    case "UndefinedKeyword":
    case "VoidKeyword":
    case "NeverKeyword":
    case "UnknownKeyword":
    case "AnyKeyword":
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
    case "ObjectKeyword":
      return that._tag === self._tag;
    case "TemplateLiteral":
      return isTemplateLiteral(that) && that.head === self.head && equalsTemplateLiteralSpan(that.spans, self.spans);
    case "Enums":
      return isEnums(that) && equalsEnums(that.enums, self.enums);
    case "Refinement":
    case "TupleType":
    case "TypeLiteral":
    case "Union":
    case "Suspend":
    case "Transformation":
    case "Declaration":
      return self === that;
  }
};
const intersection = /*#__PURE__*/Arr.intersectionWith(equals);
const _keyof = ast => {
  switch (ast._tag) {
    case "Declaration":
      {
        const annotation = getSurrogateAnnotation(ast);
        if (Option.isSome(annotation)) {
          return _keyof(annotation.value);
        }
        break;
      }
    case "TypeLiteral":
      return ast.propertySignatures.map(p => Predicate.isSymbol(p.name) ? new UniqueSymbol(p.name) : new Literal(p.name)).concat(ast.indexSignatures.map(is => getParameterBase(is.parameter)));
    case "Suspend":
      return _keyof(ast.f());
    case "Union":
      return ast.types.slice(1).reduce((out, ast) => intersection(out, _keyof(ast)), _keyof(ast.types[0]));
    case "Transformation":
      return _keyof(ast.to);
  }
  throw new Error(errors_.getAPIErrorMessage("KeyOf", `unsupported schema (${ast})`));
};
/** @internal */
export const compose = (ab, cd) => new Transformation(ab, cd, composeTransformation);
/** @internal */
export const rename = (ast, mapping) => {
  switch (ast._tag) {
    case "TypeLiteral":
      {
        const propertySignatureTransformations = [];
        for (const key of util_.ownKeys(mapping)) {
          const name = mapping[key];
          if (name !== undefined) {
            propertySignatureTransformations.push(new PropertySignatureTransformation(key, name, identity, identity));
          }
        }
        if (propertySignatureTransformations.length === 0) {
          return ast;
        }
        return new Transformation(ast, new TypeLiteral(ast.propertySignatures.map(ps => {
          const name = mapping[ps.name];
          return new PropertySignature(name === undefined ? ps.name : name, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations);
        }), ast.indexSignatures), new TypeLiteralTransformation(propertySignatureTransformations));
      }
    case "Suspend":
      return new Suspend(() => rename(ast.f(), mapping));
    case "Transformation":
      return compose(ast, rename(typeAST(ast), mapping));
  }
  throw new Error(`rename: cannot rename (${ast})`);
};
const formatKeyword = (ast, verbose = false) => Option.getOrElse(getExpected(ast, verbose), () => ast._tag);
const getExpected = (ast, verbose) => {
  if (verbose) {
    const description = getDescriptionAnnotation(ast).pipe(Option.orElse(() => getTitleAnnotation(ast)));
    return Option.match(getIdentifierAnnotation(ast), {
      onNone: () => description,
      onSome: identifier => Option.match(description, {
        onNone: () => Option.some(identifier),
        onSome: description => Option.some(`${identifier} (${description})`)
      })
    });
  } else {
    return getIdentifierAnnotation(ast).pipe(Option.orElse(() => getTitleAnnotation(ast)), Option.orElse(() => getDescriptionAnnotation(ast)));
  }
};
//# sourceMappingURL=AST.js.map